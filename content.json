{"meta":{"title":"夜明的Blog","subtitle":"Daybreak","description":"Where would a south wind take us","author":"夜明","url":"https://daybreakland.top","root":"/"},"pages":[],"posts":[{"title":"线性结构|线性表","slug":"2.0线性表","date":"2019-12-03T09:40:48.000Z","updated":"2019-12-03T09:44:03.274Z","comments":true,"path":"2019/12/03/2.0线性表/","link":"","permalink":"https://daybreakland.top/2019/12/03/2.0%E7%BA%BF%E6%80%A7%E8%A1%A8/","excerpt":"本篇记录了数据结构的线性表部分。","text":"本篇记录了数据结构的线性表部分。 主要内容线性结构特点在非空有限集内，存在唯一始末元素、除头全有唯一前驱，除尾全有唯一后继。 2.1 线性表的类型定义 2.2 线性表的顺序表示与实现 2.3 线性表的链式表示与实现 2.3.1 线性链表 2.3.2 循环链表 2.3.3 双向链表 线性表的逻辑结构定义一个线性表是n个数据元素的有限序列 特点1.线性表中所有元素的性质相同。 2.除第一个和最后一个数据元素之外，其它数据元素有且仅有一个前驱和一个后继。第一个数据元素无前驱，最后一个数据元素无后继。 3.数据元素在表中的位置只取决于它自身的序号。 ADT1234567891011121314151617ADT List&#123; 数据对象：D=&#123;ai|ai∈ElemSet,i=1,2,…,n,n≥0&#125; 数据关系：R=&#123;&lt;ai-1,ai&gt;|ai,ai-1∈D,1=2,…,n&#125; 基本操作： InitList( &amp;L); DestroyList(&amp;L); ClearList(&amp;L); ListEmpty(L); ListLength(L); GetElement(L,i,&amp;e); LocateElement(L,e,compare( )) PriorElement(L,cur_e,&amp;pre_e) NextElement(L,cur_e,&amp;next_e) ListInsert(&amp;L,i,e); ListDelete(&amp;L,i,&amp;e); ListTraverse(L,visit( ))&#125;ADT List 例题线性表合并假设有两个集合A和B分别用两个线性表LA和LB表示,现要求一个新的集合A＝A∪B。 12345678910111213void union( List &amp;La, List Lb)&#123; // 将所有在线性表Lb中但不在La中的数据元素插入到La中 La_Len = ListLength( La ); // 求线性表的长度 Lb_Len = ListLength( Lb ); for( i = 1; i &lt;= Lb_Len; i++) &#123; GetElem( Lb, i, e); // 取Lb中第i个数据元素赋给e if( !LocateElem( La, e, equal)) ListInsert( La, ++La_Len, e); // La中不存在和 e 相同的数据元素，则插入之 &#125;&#125; // union 时间复杂度： O(ListLength( La ) * ListLength( Lb )) 非递减线性表La,Lb的合并123456789101112131415161718192021222324252627void MergeList( List La, List Lb, List &amp;Lc )&#123; InitList( Lc ); i = j = 1; // i和j分别是La和Lb的序号 k = 0; //k是Lc的序号 La_Len = ListLength( La ); Lb_Len = ListLength( Lb ); while((i &lt;= La_Len) &amp;&amp; (j &lt;= Lb_Len)) &#123; GetElem( La, i, ai ); GetElem( Lb, j, bj ); if( ai &lt; = bj ) &#123; ListInsert( Lc, ++k, ai); ++i; &#125; else &#123; ListInsert( Lc, ++k, bj ); ++j; &#125; &#125; while( i &lt;= La_Len )&#123;//若La非空，把La剩余的数据元素插入到Lc中 GetElem( La, i++, ai ); ListInsert( Lc, ++k, ai ); &#125; while( j &lt;= Lb_Len )&#123;//若Lb非空，把La剩余的数据元素插入到Lc中 GetElem( Lb, j++, bj ); ListInsert( Lc, ++k, bj ); &#125;&#125;//MergeList 时间复杂度： O(ListLength(La ) + ListLength( Lb)) 线性表的顺序存储结构顺序表：用一组地址连续的存储单元存放一个线性表 元素地址计算方法：LOC(ai)=LOC(a1)+(i-1)*LL—一个元素占用的存储单元个数LOC(ai)—线性表第i个元素的地址 特点： 实现逻辑上相邻—物理地址相邻 实现随机存取 顺序表的类型定义1234567#define LIST_INIT_SIZE 100 // 线性表存储空间的初始分配量 #define LISTINCREMENT 10 // 线性表存储空间的分配增量typedef struct&#123; ElemType *elem；//存储空间基址 int length； //当前长度 int listsize //当前分配的存储容量（以sizeof（ElemType）为单位）&#125;Sqlist； 顺序表的重要操作初始化顺序表123456789Status InitList_Sq(SqList &amp;L)&#123; //构造一个空的顺序表L L.elem=(ElemType*)malloc(LIST_INIT_SIZE*sizeof(ElemType)); if (! L.elem) exit(OVERFLOW); //存储分配失败 L.length=0; //空表长度为0 L.listsize=LIST_INIT_SIZE; //初始存储容量 Return OK;&#125;//InitList_Sq 顺序表的插入操作思路1.输入是否有效？2.当前表是否已经满？3.移动 i 后的元素4.插入元素5.表长增1 代码12345678910111213141516171819Status ListInsert_Sq(Sqlist &amp;L, int i, ElemType e) &#123; // 在顺序线性表L的第i个位置之前插入新的元素e // i的合法值为1&lt;=i&lt;=ListLength_Sq(L) + 1 if(i&lt;1 || i&gt;L.length+1) return ERROR; //i值不合法 if(L.length&gt;=L.listsize)&#123; // 当前存储空间已满,增加分配 newbase=(ElemType*)realloc(L.elem,(L.listsize+LISTINCREMENT)*sizeof(ElemType)); if(!newbase) exit(OVERFLOW); // 存储分配失败 L.elem=newbase; L.listsize+=LISTINCREMENT; // 增加存储容量 &#125; q=&amp;(L.elem[i-1]); // q为插入位置 for(p=&amp;(L.elem[L.length-1]); p&gt;=q; --p) *(p+1)=*p; // 插入位置及之后的元素后移 *q=e; // 插入e ++L.length; // 表长增1 return OK;&#125; 顺序表的删除操作思路1.输入是否有效？2.删除（前移元素）3.表长减1 代码12345678910111213Status ListDelete_Sq(SqList &amp;L,int i,ElemType &amp;e)&#123;//在顺序线性表L中删除第.i个元素，并用e返回其值 //i的合法值为 1≤i≤L.length if((i&lt;1)||(i&gt;L.Length)) return ERROR; // i值不合法或表空 p=&amp;(L.elem[i-1]); //p为被删除元素的位置 e=*p; // 被删除元素的值赋给e q=L.elem+L.length-1; // 表尾元素的位置 for (++p; p&lt;=q;++p) *(p-1)=*p; //被删除元素之后的元素前移 --L.length; //表长减1 return OK; &#125;//ListDelete_Sq 顺序表的查找操作1234567891011int LocateElem(SqList L,ElemType e, Status(*compare)(ElemType,ElemType))&#123; ElemType *p; int i=1; // i的初值为第1个元素的位序 p=L.elem; // p的初值为第1个元素的存储位置 while(i&lt;=L.length&amp;&amp;!compare(*p++,e)) ++i; if(i&lt;=L.length) return i; else return 0; &#125; 顺序表的遍历（函数指针使用说明书） 初始条件：顺序线性表L已存在 操作结果：依次对L的每个数据元素调用函数vi()。一旦vi()失败，则操作失败。若在vi()的形参加’&amp;’，表明可通过调用vi()改变元素的值。 12345678Status ListTraverse(SqList ,void(*vi)(ElemType&amp;))&#123; ElemType *p; int i; p=L.elem; for(i=1;i&lt;=L.length;i++) vi(*p++); return OK;&#125; 顺序表的一般操作销毁顺序表123456789Status DestroyList_Sq ( SqList &amp;L) &#123; if (!L.elem) return ERROR; // 若表L不存在 free (L.elem); // 若表L已存在，回收动态分配的存储空间 L.elem = null; L.length = 0; L.Listsize = 0; return OK; &#125;// DetroyList_Sq 置空线性表1234567 Status ClearList_Sq ( SqList &amp;L) &#123; if (!L.elem) return ERROR; // 若表L不存在 L.length = 0; //若表L已存在，将L置空 return OK; &#125;// ClearList_Sq 判断空表12345678Status ListEmpty(SqList L) &#123; // 初始条件：顺序线性表L已存在。 //操作结果：若L为空表，则返回TRUE，否则返回FALSE if(L.length==0) return TRUE; else return FALSE; &#125; 求表长12345int ListLength(SqList L)&#123; //初始条件：顺序线性表L已存在。 //操作结果：返回L中数据元素个数 return L.length;&#125; 取元素操作123456Status GetElem_Sq ( SqList L, int i, ElemType &amp;e ) &#123; if((i&lt; 1)||(i&gt;L.length)) return ERROR; // i 非法 e=L.elem[i-1]; //将顺序表中第i 个元素赋值给 e return OK; &#125;// GetElem_Sq 顺序存储结构的优缺点优点 逻辑相邻，物理相邻 可随机存取任一元素 存储空间使用紧凑缺点 插入、删除操作需要移动大量的元素 预先分配空间需按最大空间分配，利用不充分 表容量难以扩充线性表的链式存储结构特点 用一组任意的存储单元存储线性表的数据元素 利用指针实现了用不相邻的存储单元存放逻辑上相邻的元素 每个数据元素ai，除存储本身信息外，还需存储其直接后继的信息 结点{数据域：元素本身信息 指针域：指示直接后继的存储位置}线性链表的定义结点中只含一个指针域的链表叫线性链表，也叫单链表。 1234typedef struct LNode &#123; ElemType data; struct LNode *next;&#125;Lnode,*LinkList; LNode* p 和 LinkList p意思一样，都是建立一个Lnode型的单链表定义出来的都是1个Lnode型的指针变量，通常用他指向头结点特别地，注意LinkList P,Q; /P,Q都是指针 /LNode P,Q;/*只有P是指针 / 头结点在单链表第一个结点前附设一个结点叫头结点头结点指针域为空表示线性表为空链表的重要操作初始化链表1234567Status InitList_L (LinkList &amp;L) &#123; L = (LinkList)malloc(sizeof(LNode)); if (!L) exit(OVERFLOW); L-&gt;next = null; Return OK; &#125;// InitList_L 链表的按值查找123456789Status LocateNode_L(LinkList L，Elemtype key，LNode &amp;e)&#123; p=L–&gt;next; while( p &amp;&amp; p–&gt;data!=key) p=p–&gt;next; if(!p) return ERROR; e=p; return OK;&#125; 链表的插入操作思路 1.寻找第i-1个结点:顺指针向后查找，直到p指向第i-1个元素或p-&gt;next为空2.分配新空间3.插入节点 代码123456789101112131415Status ListInsert_L(LinkList &amp;L, int i, ElemType e)&#123; //在带头结点的线性链表L中第i元素结点之前插入元素e p=L; j=0 while (p&amp;&amp;j&lt;i-1)&#123; p=p-&gt;next; ++j; &#125;//☆寻找第i-1个元素结点 if(!p||j&gt;i-1) return ERROR; // i小于1 则 j&gt;i-1 // i大于表长+1 则p为空 s=(LinkList)malloc(sizeof(LNode)); //分配新结点 s-&gt;data=e; s-&gt;next=p-&gt;next; p-&gt;next=s; //插入新结点 return OK;&#125;//LinstInsert_L 链表的删除操作思路1.寻找第i-1个结点:顺指针向后查找，直到p指向第i-1个元素或p-&gt;next为空2.删除结点(修改其后继指针)3.回收（释放）结点空间 代码1234567891011121314Status ListDelete_L(LinkList &amp;L, int i, ElemType &amp;e)&#123; //在带头结点的单链线性表L中，删除第i个元素，并由e返回其值 p=L; j=0; while (p-&gt;next&amp;&amp;j&lt;i-1)&#123; //寻找第i-1个结点 p=p-&gt;next; ++j; &#125; if(!(p-&gt;next)||j&gt;i-1) return ERROR; // 表中无第i个结点(i不合法) // i&lt;1 则 j&gt;i-1 // i&gt;表长 则 p-&gt;next为空 q=p-&gt;next;p-&gt;next=q-&gt;next; //删除结点 e =q-&gt;data; free(q); // 释放结点空间 return OK;&#125;//LinstDelete_L 链表的一般操作取元素操作123456789101112Status GetElem_L(LinkList L, int i, ElemType &amp;e)&#123; //L为带头结点的单链表的头指针。 //当第i个元素存在时，其值赋给e并返回OK，否则返回ERROR p=L-&gt;next; j=1; //初始化，p指向第一个结点，j为计数器 while(p&amp;&amp; j&lt;i)&#123; //顺指针向后查找，直到p指向第i个元素或p为空 p=p-&gt;next;++j; &#125; if (!p||j&gt;i) return ERROR; //第i个元素不存在 e=p-&gt;data; //取第i个元素 return OK;&#125;//GetElem_L 头插法建立单链表思路① 建立新节点② 向新节点中添入内容③ 使新节点指向链头(第一个元素)④ 改变头指针,指向新节点 代码12345678910void CreateList_L(LinkList &amp;L, int n) &#123; //逆序输入n个元素的值，建立带表头结点的线性链表 L=（LinkList）malloc(sizeof (LNode)); L-&gt;next=NULL; //先建立一个带头结点的单链表 for (i=n; i&gt;0;--i)&#123; p=(LinkList)malloc(sizeof(LNode));//生成新结点 scanf(&amp;p-&gt;data);//输入元素值 p-&gt;next=L-&gt;next;L-&gt;next=p; //插入到表头/ &#125;&#125;//CreateList_L 头插法的幻想图插了一个想不明白就想两个节点 尾插法建立单链表思路① 建立新节点② 向新节点中添入内容③ 将新节点链入链尾④ 改变尾指针 代码12345678910111213void CreateList_L(LinkList &amp;L, int n) &#123; //输入n个元素的值，建立带表头结点的线性链表 L=（LinkList）malloc(sizeof (LNode)); L-&gt;next=NULL; //先建立一个带头结点的单链表 r=L; for (i=1; i&lt;=n;i++)&#123; p=(LinkList)malloc(sizeof(LNode));//生成新结点 scanf(&amp;p-&gt;data);//输入元素值 p-&gt;next=NULL; r-&gt;next=p; r=p; &#125;&#125;//CreateList_L 归并2个有序链表12345678910111213141516171819void MergeList_L(LinkList &amp;La, LinkList &amp;Lb, LinkList &amp;Lc)&#123; pa=La-&gt;next; pb=Lb-&gt;next; Lc=pc=La; //用La的头结点作为Lc的头结点 while(pa &amp;&amp; pb)&#123; if (pa-&gt;data&lt;=pb-&gt;data)&#123; pc-&gt;next=pa; pc=pa; pa=pa-&gt;next; &#125; else &#123; pc-&gt;next=pb; pc=pb; pb=pb-&gt;next; &#125; &#125; pc-&gt;next=pa?pa:pb;//插入剩余段 free(Lb);//释放Lb的头结点&#125;//MergeList_L 单链表结构的优缺点优点 动态结构，整个存储空间为多个链表共用 不需预先分配空间缺点 指针占用额外存储空间 不能随机存取，查找速度慢循环链表 在单链表中，将终端结点的指针域NULL改为指向表头结点的或开始结点，就得到了单链形式的循环链表，并简单称为单循环链表。 为了使空表和非空表的处理一致，循环链表中也可设置一个头结点。 由于循环链表中没有NULL指针，故涉及遍历操作时，其终止条件就不再像非循环链表那样判断p或p—&gt;next是否为空，而是判断它们是否等于头指针。双向链表结构定义12345typedef struct DulNode &#123; ElemType data; struct DuLNode *prior; struct DuLNode *next;&#125;DuLNode, *DuLinkList; 插入结点程序 1234567891011Status ListInsert_DuL(DuLinklist L, int i, ElemType e)&#123; DuLinklist s,p; if (!(p=GetElemP_DuL(L,i))) return ERROR; // 在L中确定第i个元素的位置指针p if(!(s = (DuLinklist)malloc(sizeof(DuLNode)))) return ERROR; s-&gt;data = e; // 构造数据为e的结点s s-&gt;prior = p-&gt;prior; p-&gt; prior -&gt;next = s; s-&gt;next = p; p-&gt;prior = s; return OK;&#125; // ListInsert_DuL 删除结点程序1234567891011Status ListDelete_DuL(DuLinklist L, int i, ElemType &amp;e)&#123; DuLinklist p; if (!(p=GetElemP_DuL(L,i))) return ERROR; // 在L中确定第i个元素的位置指针p e = p-&gt;data; // 删除的结点的值存入e p-&gt; prior -&gt;next = p-&gt;next; p-&gt;next-&gt;prior = p-&gt;prior; free(p); return OK;&#125; // ListDelete_DuL 带头结点的线性链表类型具有实用意义的线性链表 1234567891011typedef struct LNode // 结点类型&#123; ElemType data; LNode *next;&#125;*Link,*Position;struct LinkList // 链表类型&#123; Link head,tail; // 分别指向线性链表中的头结点和最后一个结点 int len; // 指示线性链表中数据元素的个数&#125;;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://daybreakland.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"树-3|树和森林","slug":"6.3树和森林","date":"2019-12-03T05:03:55.000Z","updated":"2019-12-03T05:12:03.410Z","comments":true,"path":"2019/12/03/6.3树和森林/","link":"","permalink":"https://daybreakland.top/2019/12/03/6.3%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/","excerpt":"本篇记录了数据结构树这一章学习的第三部分，即树和森林。","text":"本篇记录了数据结构树这一章学习的第三部分，即树和森林。 树的存储结构双亲表示法取一块连续的内存空间，在存储每个结点的同时，各自都附加一个记录其双亲结点位置的变量。 代码实现12345typedef struct PTNode //结点结构&#123; ElemType data; int parent;//结点的父结点在数组中的位置下标&#125;PTNode; 孩子表示法将树中的每个结点的孩子结点排列成一个线性表，用链表存储起来。对于含有 n 个结点的树来说，就会有 n 个单链表，再把 n 个单链表的头指针存储在一个线性表中。如果结点没有孩子，则其单链表为空。 代码表示1234567891011121314151617typedef struct CTNode//每个节点的孩子链表&#123; int child; //数据在数组中存储的位置下标 struct CTNode *next;&#125;*ChildPtr;typedef struct //每个节点的信息&#123; TElemType data; ChildPtr firstchild; //孩子链表的头指针&#125;CTBox;typedef struct//全树&#123; CTBox nodes[Tree_Size]; //存储结点的数组 int n, r; //结点数量和树根的位置&#125;CTree; 孩子兄弟表示法（二叉树表示法） 代码表示 12345typedef struct CSNode&#123; ElemType data; struct CSNode *firstchild, *nextsibling;&#125;CSNode, *CSTree; 通过孩子兄弟表示法，普通树转化为了二叉树，所以孩子兄弟表示法又被称为“二叉树表示法”或者“二叉链表表示法”。 森林与二叉树转换将树转换成二叉树加线：在兄弟之间加一连线抹线：对每个结点，除了其左孩子外，去除其与其余孩子之间的关系旋转：以树的根结点为轴心，将整树顺时针转45° 将二叉树转换成树加线：若p结点是双亲结点的左孩子，则将p的右孩子，右孩子的右孩子，……沿分支找到的所有右孩子，都与p的双亲用线连起来抹线：抹掉原二叉树中双亲与右孩子之间的连线调整：将结点按层次排列，形成树结构 森林转换成二叉树将各棵树分别转换成二叉树将每棵树的根结点用线相连以第一棵树根结点为二叉树的根，再以根结点为轴心，顺时针旋转，构成二叉树型结构 二叉树转换成森林抹线：将二叉树中根结点与其右孩子连线，及沿右分支搜索到的所有右孩子间连线全部抹掉，使之变成孤立的二叉树还原：将孤立的二叉树还原成树 树和森林的遍历树的遍历遍历按一定规律走遍树的各个顶点，且使每一顶点仅被访问一次，即找一个完整而有规律的走法，以得到树中所有结点的一个线性排列 常用方法 先根（序）遍历：先访问树的根结点，然后依次先根遍历根的每棵子树 后根（序）遍历：先依次后根遍历每棵子树，然后访问根结点 按层次遍历：先访问第一层上的结点，然后依次遍历第二层，……第n层的结点森林遍历 先序遍历森林若森林非空：访问森林中第一棵树的根结点；先序遍历第一棵树根结点的子树森林；先序遍历除第一棵树后剩余的树构成的森林； 中序遍历森林若森林非空：中序遍历第一棵树根结点的子树森林；访问第一棵树的根结点；中序遍历除第一棵树后剩余的树构成的森林；哈夫曼树(Huffman)带权路径长度最短的树基本概念 路径：从树中一个结点到另一个结点之间的分支构成这两个结点间的~ 路径长度：路径上的分支数目 树的路径长度：从树根到每一个结点的路径长度之和 树的带权路径长度：树中所有带权叶子结点的路径长度之和Huffman树设有n个权值{w1,w2,……wn}，构造一棵有n个叶子结点的二叉树，每个叶子的权值为wi,则wpl最小的二叉树叫Huffman树Huffman算法 构造Huffman树步骤》根据给定的n个权值{w1,w2,……wn}，构造n棵只有根结点的二叉树，令其权值为wj。》在森林中选取两棵根结点权值最小的树作左右子树，构造一棵新的二叉树，置新二叉树根结点权值为其左右子树根结点权值之和。》在森林中删除这两棵树，同时将新得到的二叉树加入森林中。》重复上述两步，直到只含一棵树为止，这棵树即哈夫曼树。Huffman编码哈弗曼编码是数据通信用的二进制编码 思想：根据字符出现频率编码，使电文总长最短 编码：根据字符出现频率构造Huffman树，然后将树中结点引向其左孩子的分支标“0”，引向其右孩子的分支标“1”（左0右1）；每个字符的编码即为从根到每个叶子的路径上得到的0、1序列","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://daybreakland.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"树-2|遍历二叉树","slug":"6.2遍历二叉树","date":"2019-12-03T05:03:42.000Z","updated":"2019-12-03T05:11:46.006Z","comments":true,"path":"2019/12/03/6.2遍历二叉树/","link":"","permalink":"https://daybreakland.top/2019/12/03/6.2%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"本篇记录了数据结构树这一章学习的第二部分，即遍历二叉树。","text":"本篇记录了数据结构树这一章学习的第二部分，即遍历二叉树。 遍历二叉树树的常见操作建树123456789101112131415161718Status CreateBiTree(BiTree &amp;T) &#123; // 算法6.4:按先序次序输入二叉树中结点的值（可为字符型或整型，在主程中 // 定义），构造二叉链表表示的二叉树T。变量Nil表示空（子）树。有改动 TElemType ch; cin&gt;&gt;ch; if(ch==Nil) // 空 T=NULL; else &#123; T=(BiTree)malloc(sizeof(BiTNode)); if(!T) exit(OVERFLOW); T-&gt;data=ch; // 生成根结点 CreateBiTree(T-&gt;lchild); // 构造左子树 CreateBiTree(T-&gt;rchild); // 构造右子树 &#125; &#125; 求树的深度123456789101112131415int BiTreeDepth(BiTree T) &#123; // 初始条件: 二叉树T存在。操作结果: 返回T的深度 int i,j; if(!T) return 0; if(T-&gt;lchild) i=BiTreeDepth(T-&gt;lchild); else i=0; if(T-&gt;rchild) j=BiTreeDepth(T-&gt;rchild); else j=0; return i&gt;j?i+1:j+1; &#125; 插入子树123456789101112131415161718192021Status InsertChild(BiTree p,int LR,BiTree c) // 形参T无用 &#123; // 初始条件: 二叉树T存在,p指向T中某个结点,LR为0或1,非空二叉树c与T // 不相交且右子树为空 // 操作结果: 根据LR为0或1,插入c为T中p所指结点的左或右子树。p所指结点的 // 原有左或右子树则成为c的右子树 if(p) // p不空 &#123; if(LR==0) &#123; c-&gt;rchild=p-&gt;lchild; p-&gt;lchild=c; &#125; else // LR==1 &#123; c-&gt;rchild=p-&gt;rchild; p-&gt;rchild=c; &#125; return OK; &#125; return ERROR; // p空 &#125; 前序递归遍历二叉树12345678910void PreOrderTraverse(BiTree T,Status(*Visit)(TElemType)) &#123; // 初始条件: 二叉树T存在,Visit是对结点操作的应用函数。算法6.1，有改动 // 操作结果: 先序递归遍历T,对每个结点调用函数Visit一次且仅一次 if(T) // T不空 &#123; Visit(T-&gt;data); // 先访问根结点 PreOrderTraverse(T-&gt;lchild,Visit); // 再先序遍历左子树 PreOrderTraverse(T-&gt;rchild,Visit); // 最后先序遍历右子树 &#125; &#125; 前中后序的递归算法只是更改了visit(T-&gt;data)语句位置，前中后分别对应位置1、2、3 中序遍历二叉树1234567891011121314Status InOrderTraverse( BiTree T, status (*visit)(TElemType e ))&#123; InitStack( S ); Push( S, T ); // 根指针进栈 while( ! StackEmpty( S ))&#123; while( GetTop( S, p ) &amp;&amp; p ) Push( S, p-&gt;lChild );//向左，直到最左下角 Pop( S, p ); // NULL退栈 if( !StackEmpty( S))&#123; Pop( S, p ); // 根退出 if( ! ( *Visit)(p-&gt;data) ) return ERROR; Push( S, p-&gt;RChild ); &#125;// if &#125;// while return OK;&#125;// InOrderTraverse 二叉树的计数由二叉树的前序序列和中序序列可唯一地确定一棵二叉树。 线索二叉树定义前驱与后继在二叉树的先序、中序或后序遍历序列中两个相邻的结点互称为~ 线索指向前驱或后继结点的指针称为~ 线索二叉树加上线索的二叉链表表示的二叉树叫~ 线索化对二叉树按某种遍历次序使其变为线索二叉树的过程叫~ 实现 在有n个结点的二叉链表中必定有n+1个空链域 在二叉树或二叉链表中，若左孩子为空，则画出它的直接前驱，右孩子为空时，则画出它的直接后继，左右孩子不为空时，不需画前驱和后继。这样就得到了线索二叉树或线索二叉链表。对应tag为0，child域指向孩子；对应tag为1，child域指向孩子。中序线索二叉树线索二叉树的遍历线索链表的遍历算法 附带习题1 编写求二叉树的分枝结点个数的算法（用二叉链表存） 2 二叉树求二叉树深度算法","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://daybreakland.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"树-1|树和二叉树","slug":"6.1树和二叉树","date":"2019-12-03T05:03:08.000Z","updated":"2019-12-03T05:12:46.449Z","comments":true,"path":"2019/12/03/6.1树和二叉树/","link":"","permalink":"https://daybreakland.top/2019/12/03/6.1%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"本篇记录了数据结构树这一章学习的第一部分，即树和二叉树。","text":"本篇记录了数据结构树这一章学习的第一部分，即树和二叉树。 树的定义和基本概念定义树(tree)是n(n&gt;0)个结点的有限集T，其中：有且仅有一个特定的结点，称为树的根(root)当n&gt;1时，其余结点可分为m(m&gt;0)个互不相交的有限集T1,T2,……Tm，其中每一个集合本身又是一棵树，称为根的子树(subtree) 特点：树中至少有一个结点——根树中各子树是互不相交的集合基本术语结点(node)指树中的一个数据元素，包括数据项及若干指向其子树的分支。一般用一个字母表示。结点的度(degree)结点拥有的子树数叶子(leaf)度为0的结点，也叫终端结点。 分枝结点除叶子结点外的所有结点，也叫非终端结点。孩子(child)结点子树的根称为该结点的孩子双亲(parents)孩子结点的上层结点叫该结点的~祖先结点从根结点到该结点所经过分枝上的所有结点为该结点的祖先，如图6-1c中M的祖先有A，D ，H 。子孙结点某一结点的子女及子女的子女都为该结点子孙。兄弟(sibling)具有同一个双亲的结点树的度一棵树中最大的结点度数结点的层次(level)从根结点算起，根为第一层，它的孩子为第二层……深度(depth)树中结点的最大层次数有序树若一棵树中所有子树从左到右的排序是有顺序的，不能颠倒次序。称该树为有序树。无序树若一棵树中所有子树的次序无关紧要，则称为无序树。森林(forest)m(m&gt;=0)棵互不相交的树的集合.一棵树可以看成是一个特殊的森林。ADT 12345678910111213141516171819202122232425262728ADT Tree&#123; 数据对象D：D是具有相同特性的数据元素的集合 数据关系R： 若D为空集，则称为空树； 若D仅含一个数据元素，则R为空集，否则R=&#123;H&#125;， H是如下二元关系： 在D中存在唯一的称为根的数据元素root，它在关系H下无前驱； 若D-&#123;root&#125;≠Φ,则存在D-&#123;root&#125;的一个划分D1,D2,…Dm(m&gt;0)，对任意j≠k (1≤j,k≤m)又Dj∩Dk=Φ,且对任意的i(1≤i≤m)，唯一存在数据元素xi∈Di，有&lt;root,xi&gt;∈H; 对应于D-&#123;root&#125;的划分，H - &#123;&lt;root,x1&gt;, … &lt;root , xm&gt; &#125; 有唯一的一个划分H1,H2,…Hm，m&gt;0，对任意j≠k(1≤j,k≤m)有Hj∩Hk=Φ，且对任意i（1≤i≤m），Hi是Di上的二元关系，(Di,&#123;Hi&#125;）是一棵符合本定义的树，称为根root的子树。 基本操作： InitTree( &amp;T ); // 初始化 DestroyTree( &amp;T ); // 销毁 CreateTree( &amp;T, definition);//按definition构造树 ClearTree( &amp;T ); // 清空 TreeEmpty( T ); // 空？ TreeDepth( T ); // 树的深度 Root( T ); // 树根 Value( T, cur_e ); // 求结点cur_e的值 Assign( T, cur_e, value ); // 赋值 Parent( T, cur_e ); // 求cur_e的双亲 LeftChild( T, cur_e ); // 求cur_e的最左孩子 RightSibling( T, cur_e );// 求cur_e的右兄弟 InsertChild( &amp;T, &amp;p, i, c );// 插入c为T中p所指结点的第i棵子树 DeleteChild( &amp;T, &amp;p, i);// 删除T中，p所指结点的第i个子树 TraverseTree( T, visit() ); //遍历 &#125;//ADT Tree 二叉树定义二叉树是n(n&gt;=0)个结点的有限集，它或为空树(n=0)，或由一个根结点和两棵分别称为左子树和右子树的互不相交的二叉树构成 特点每个结点至多有二棵子树(即不存在度大于2的结点)二叉树的子树有左、右之分，且其次序不能任意颠倒二叉树的ADT表示 123456789101112131415161718192021222324252627282930313233343536373839ADT BinaryTree&#123; 数据对象D：D是具有相同特性的数据元素的集合； 数据关系R: 若D = Φ，则 R = Φ， 称BinaryTree为空二叉树； 若D ≠ Φ，则 R = &#123; H &#125;, H是如下的二元关系： (1) 在D中，存在唯一的称为根的数据元素 root, 它在关系H下无前驱； (2) 若D – &#123;root&#125; ≠ Φ, 则存在 D-&#123;root&#125; = &#123;Dl, Dr&#125;, 且 Dl ∩Dr = Φ； (3) 若Dl ≠ Φ, 则Dl中存在唯一的元素xl, &lt;root, xl&gt; ∈ H, 且存在Dl上的关系Hl ∈H； 若Dr ≠ Φ,则Dr中存在唯一的元素xr,&lt;root,xr&gt;∈H, 且存在Dr上的关系Hr ∈H； H = &#123; &lt;root, xl&gt;,&lt;root, xr&gt;, Hl, Hr&#125;; (4) ( Dl,&#123; Hl&#125;)是一棵符合本定义的二叉树，称为根的左子树； ( Dr, &#123;Hr&#125;)是一棵符合本定义的二叉树，称为根的右子树； 基本操作： InitBiTree( &amp;T ); // 初始化 DestroyBiTree( &amp;T ); // 销毁 CreateBiTree( &amp;T, definition ); // 创建二叉树 ClearBiTree( &amp;T ); // 清空 BiTreeEmpty( T ); // 空？ BiTreeDepth( T ); // 深度 Root( T ); // 根 Value( T, e ); // 求e的值 Assign( T, &amp;e, value ); // 赋值 Parent( T, e ); // 求双亲 LeftChild( T, e ); // 左孩子 RightChild( T, e ); // 右孩子 LeftSibling( T, e) ; // 左兄弟 RightSibling( T, e ); // 右兄弟 InsertChild( T, p, LR, c ); // 插入 DeleteChild( T, p, LR ); // 删除 PreOrderTraverse( T, Visit( )); // 先序遍历 InOrderTraverse( T, Visit( )); // 中序遍历 PostOrderTraverse( T, Visit( )); // 后序遍历 LeverOrderTraverse( T, Visit( )); // 层序遍历&#125; // ADT BinaryTree 二叉树的性质 性质1：在二叉树的第i层上至多有2^(i-1)个结点(i≥1) 性质2：深度为k的二叉树至多有2^(k-1)个结点(k≥1) 性质3：对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1 性质4：具有n个结点的完全二叉树的深度为floor[ log2 n ] +1 性质5：如果对一棵有n个结点的完全二叉树的结点按层序编号，则对任一结点i(1&lt;=i&lt;=n)，有：(1) 如果i=1，则结点i是二叉树的根，无双亲；如果i&gt;1，则其双亲是florr[i/2](2) 如果2i&gt;n，则结点i无左孩子；如果2i&lt;=n，则其左孩子是2i(3) 如果2i+1&gt;n，则结点i无右孩子；如果2i+1&lt;=n，则其右孩子是2i+1 特殊的二叉树满二叉树深度为k，其一共有2^(k)-1个节点（每一层都满了） 完全二叉树深度为k，有n个结点的二叉树当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应（最后一层，从最右节点去掉连续节点后的满二叉树） 二叉树的存储结构顺序存储结构更适合存储完全二叉树，一般二叉树会浪费空间 链式存储结构二叉链表1234typedef struct BitNode&#123; TElemType data; struct BitNode *lchild,*rchild;&#125;BiTNode,*BiTree; 三叉链表1234typedef struct node&#123; Elemtype data; struct node *lchild,*rchild,*parent;&#125;;BiTNode, *BiTree;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://daybreakland.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"绪论|数据结构","slug":"1.0绪论","date":"2019-12-03T04:59:51.000Z","updated":"2019-12-03T05:13:29.493Z","comments":true,"path":"2019/12/03/1.0绪论/","link":"","permalink":"https://daybreakland.top/2019/12/03/1.0%E7%BB%AA%E8%AE%BA/","excerpt":"本篇记录了数据结构的绪论部分。","text":"本篇记录了数据结构的绪论部分。 主要内容 什么是数据结构 一些基本概念和术语 算法和算法分析 时间复杂度的渐进表示法 什么是数据结构 程序=数据结构+算法 数据结构是一门研究非数值计算的程序设计问题中计算机的操作对象以及它们之间的关系和操作等等的学科 基本概念和术语数据（data)所有能输入到计算机中去的描述客观事物的符号数据元素（data element）数据的基本单位，也称节点（node）或记录（record）。 有时一个数据元素可以由若干数据项(Data Item)组成。数据项（data item）有独立含义的数据最小单位，也称域(field)数据结构（data structure)数据元素和数据元素关系的集合 （带结构的数据元素的集合）四种基本数据结构集合——数据元素间除“同属于一个集合”外，无其它关系线性结构——一个对一个，如线性表、栈、队列树形结构——一个对多个，如树图状结构——多个对多个，如图 数据结构的表示图示表示图示表示是由顶点和边构成的图，其中顶点表示数据,边表示数据之间的结构关系； 二元组表示数据结构的形式定义为：数据结构是一个二元组： Data-Structure=(D，S)其中：D是数据元素的有限集，S是D上关系的有限集。 一些基本概念和术语数据结构的三个主要问题 数据的逻辑结构只抽象反映数据元素的逻辑关系 数据的存储（物理）结构数据的逻辑结构在计算机存储器中的实现 数据的逻辑结构与存储结构密切相关 算法设计-&gt; 逻辑结构 算法实现-&gt; 存储结构 数据的逻辑结构数据的存储结构存储结构分为： 顺序存储结构——借助元素在存储器中的相对位置来表示数据元素间的逻辑关系 链式存储结构——借助指示元素存储地址的指针表示数据元素间的逻辑关系 抽象数据类型ADT1234567ADT 抽象数据类型名&#123; 数据对象：&lt;数据对象的定义&gt; 数据关系：&lt;数据关系的定义&gt; 基本操作：基本操作名（参数表） 初始条件：&lt;初始条件描述&gt; 操作结果：&lt;操作结果描述&gt; &#125;ADT 抽象数据类型名 算法和算法分析算法的概念解决某一特定问题的具体步骤的描述，是指令的有限序列.其中每一条指令表示一个或多个操作。 算法的特性1 有穷性一个算法必须总是在执行有穷步之后结束，且每一步都在有穷时间内完成。 2 确定性算法中每一条指令必须有确切的含义。不存在二义性。且算法只有一个入口和一个出口。 3 可行性一个算法是可行的。即算法描述的操作都是可以通过已经实现的基本运算执行有限次来实现的。 4 输入 一个算法有零个或多个输入，这些输入取自于某个特定的对象集合。 5 输出 一个算法有一个或多个输出，这些输出是同输入有着某些特定关系的量。 算法的评价标准1 正确性(Correctness)算法应满足具体问题的需求。 2 可读性(Readability)算法应该好读。以有利于阅读者对程序的理解。 3 健壮性(Robustness)算法应具有容错处理。当输入非法数据时，算法应对其作出反应，而不是产生莫名其妙的输出结果。 4 效率与存储量需求效率指的是算法执行的时间；存储量需求指算法执行过程中所需要的最大存储空间。一般，这两者与问题的规模有关。 算法时间复杂度通常用程序中基本操作的执行次数来做为程序执行时间的评估值，并取问题规模作为自变量T(n)称作算法的渐近时间复杂度。很多算法的时间复杂度不仅与问题的规模有关，而且还与它所处理的数据集的状态有关。通常是根据数据集中可能出现的最坏情况估计出算法的最坏时间复杂度。 空间复杂度 程序所用的存储空间包括两个部分:(1)固定部分这部分空间的大小与输入输出的个数多少、数值大小无关。(2)可变部分这部分空间主要包括其尺寸与实例特征有关的成分变量所占空间、引用变量所占空间、以及递归栈所用的空间，还有算法运行时动态命令使用的空间。","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://daybreakland.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"图-6|最短路径","slug":"7.6最短路径","date":"2019-11-27T09:34:58.000Z","updated":"2019-11-27T09:17:47.991Z","comments":true,"path":"2019/11/27/7.6最短路径/","link":"","permalink":"https://daybreakland.top/2019/11/27/7.6%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/","excerpt":"本篇记录了数据结构图这一章学习的第六部分，即图的最短路径问题。","text":"本篇记录了数据结构图这一章学习的第六部分，即图的最短路径问题。 用带权的有向图表示一个交通运输网，图中： 顶点——表示城市 边——表示城市间的交通联系 权——表示此线路的长度或沿此线路运输所花的时间或费用等 问题：从某顶点出发，沿图的边到达另一顶点所经过的路径中，各边上权值之和最小的一条路径——最短路径。 从某个源点到其余各顶点的最短路径 方法一：迪杰斯特拉(Dijkstra)算法算法思想 首先，在这些最短路径中，长度最短的这条路径上必定只有一条弧，且它的权值是从源点出发的所有弧上权的最小值。 其次，第二条长度次短的最短路径只可能有两种情况： 1)或者只含一条从源点出发的弧且小于其它从源点出发的弧上的权值； 2)或者是一条只经过已求得最短路径的顶点的路径。 依次类推，按迪杰斯特拉算法先后求得的每一条最短路径必定只有两种情况，或者是由源点直接到达终点，或者是只经过已经求得最短路径的顶点到达终点。 求最短路径步骤 初使时令 S={V0},T={其余顶点}，T中顶点对应的距离值 若存在&lt;V0,Vi&gt;，为&lt;V0,Vi&gt;弧上的权值若不存在&lt;V0,Vi&gt;，为 从T中选取一个其距离值为最小的顶点W，加入S. 对T中顶点的距离值进行修改：若加进W作中间顶点，从V0到Vi的距离值比不加W的路径要短，则修改此距离值 重复上述步骤，直到S中包含所有顶点，即S=V为止 方法二：弗洛伊德(Floyd)算法算法思想逐个顶点试探法求最短路径步骤 初始时设置一个n阶方阵，令其对角线元素为0，若存在弧&lt;Vi,Vj&gt;，则对应元素为权值；否则为 逐步试着在原直接路径中增加中间顶点，若加入中间点后路径变短，则修改之；否则，维持原值 所有顶点试探完毕，算法结束","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://daybreakland.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"图-5|拓扑排序","slug":"7.5拓扑排序及关键路径","date":"2019-11-27T09:14:58.000Z","updated":"2019-11-27T09:17:36.454Z","comments":true,"path":"2019/11/27/7.5拓扑排序及关键路径/","link":"","permalink":"https://daybreakland.top/2019/11/27/7.5%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E5%8F%8A%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/","excerpt":"本篇记录了数据结构图这一章学习的第五部分，即图的拓扑排序问题。","text":"本篇记录了数据结构图这一章学习的第五部分，即图的拓扑排序问题。 拓扑排序背景 顶点——表示课程 有向弧——表示先决条件，若课程i是课程j的先决条件，则图中有弧&lt;i,j&gt; 拓扑排序学生应按怎样的顺序学习这些课程，才能无矛盾、顺利地完成学业定义AOV网用顶点表示活动，用弧表示活动间优先关系的有向图称为顶点表示活动的网(Activity On Vertex network)，简称AOV网。 若&lt;vi,vj&gt;是图中有向边，则vi是vj的直接前驱，vj是vi的直接后继；AOV网中不允许有回路，这意味着某项活动以自己为先决条件； 拓扑排序的定义把AOV网络中各顶点按照它们相互之间的优先关系排列成一个线性序列的过程叫拓扑排序 -拓扑排序应用检测AOV网中是否存在环：对有向图构造其顶点的拓扑有序序列，若网中所有顶点都在它的拓扑序列，则该AOV网必定无环 方法 在有向图中选一个没有前驱的顶点且输出之； 从图中删除该顶点和所有以它为尾的弧； 重复上述两步，直至全部顶点均已输出，或图中不存在无前驱的顶点。算法实现以邻接表作存储结构, 把邻接表中所有入度为0的顶点进栈; 栈非空时，输出栈顶元素Vj并退栈； 在邻接表中查找Vj的直接后继Vk，把Vk的入度减1；若Vk的入度为0则进栈; 重复上述操作直至栈空为止。 若栈空时输出的顶点个数不是n，则有向图有环；否则，拓扑排序完毕 1234567891011121314151617181920Status TopologicalSort(ALGraph G) &#123; for(i = 0;i &lt;G.vexnum; ++ i ) //查找入度为为零的顶点 if(! Indegree[i]) //把入度为零的顶点进栈 push (S,i ); count = 0; //计数器置0 while (! StackEmpty(s)) &#123; pop(s, i); printf(i,Gvextices[i].data); ++count;//输出顶点、计数 for(p=G.vextices[i].firstarc; p ; p = p-&gt;nextarc) &#123; k = p-&gt;adjvex; //得到与输出顶点相邻接的顶点下标 if(! (--indegree[k])) push( S,k); //将邻接点的入度减1，将为零的入栈 &#125;//for &#125;//while if (count&lt;G.vexnum) return ERROR;//该图有回路 else return OK;&#125;//TopologicalSort 关键路径背景 把工程计划表示为有向图，用顶点表示事件，弧表示活动；每个事件表示在它之前的活动已完成，在它之后的活动可以开始；事件 V1——表示整个工程开始事件 V9——表示整个工程结束其中，T为所有以第j个顶点为头的弧的集合。 定义AOE网(Activity On Edge)边表示活动的网。AOE网是一个带权的有向无环图，其中顶点表示事件，弧表示活动，权表示活动持续时间 路径长度路径上各活动持续时间之和。 关键路径路径长度最长的路径叫关键路径。 Ve——事件Vj的最早发生时间Ve(j) 源点的最早发生时间为0，其余任一顶点Vj的最早发生时间，等于从源点出发沿着各条路径达到Vj时每条路径上权的累加和的最大值。计算公式为：**Ve(j)=Max{ve(i) + dut(&lt;i ,j&gt;)} &lt;i,j&gt;∈T, j = 1,2,3…n-1** Vl—事件的最迟发生时间Vl(j) 汇点的最迟发生时间Vl[n]等于汇点的最早发生时间Ve[n]。其余任一顶点Vi的最迟发生时间等于从汇点的最迟发生时间中减去从顶点Vi出发沿着各条路径达到汇点时，每条路径上权的累加和的最大值。最迟发生时间一般用下列公式计算: Vl(i)=Min{vl(j)-dut(&lt;i ,j&gt;)} &lt;i,j&gt; ∈S, i = n -2,..,0其中， S为所有以第i个顶点为尾的弧的集合。 e(i)——表示活动ai的最早开始时间l(i)——表示活动ai的最迟开始时间 设活动ai用弧&lt;j,k&gt;表示， 其持续时间记为：dut(&lt;j,k&gt;) 则有：（1）e(i)=Ve(j) //最早开始时间是弧尾事件的最早发生时间 （2）l(i)=Vl(k)-dut(&lt;j,k&gt;)//最迟开始时间是弧头事件的最晚发生时间减去活动的持续时间，即弧的权值 l(i)-e(i)——表示完成活动ai的时间余量 关键活动——关键路径上的活动叫关键活动，即l(i)=e(i)的活动 算法实现描述 输入顶点和弧信息，建立其邻接表 计算每个顶点的入度 对其进行拓扑排序 排序过程中求顶点的Ve[i] 将得到的拓扑序列进栈 按逆拓扑序列求顶点的Vl[i] 计算每条弧的e[i]和l[i],找出e[i]=l[i]的关键活动……没看，待更新","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://daybreakland.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"图-4|图的连通性问题","slug":"7.4图的连通性问题","date":"2019-11-26T14:39:58.000Z","updated":"2019-11-27T09:17:56.773Z","comments":true,"path":"2019/11/26/7.4图的连通性问题/","link":"","permalink":"https://daybreakland.top/2019/11/26/7.4%E5%9B%BE%E7%9A%84%E8%BF%9E%E9%80%9A%E6%80%A7%E9%97%AE%E9%A2%98/","excerpt":"本篇记录了数据结构图这一章学习的第四部分，即图的连通性问题。","text":"本篇记录了数据结构图这一章学习的第四部分，即图的连通性问题。 图的连通性问题最小生成树问题提出要在n个城市间建立通信联络网，顶点——表示城市权——城市间建立通信线路所需花费代价希望找到一棵生成树，它的每条边上的权值之和（即建立该通信网所需花费的总代价）最小———最小代价生成树 n个城市间，最多可设置n(n-1)/2条线路 n个城市间建立通信网，只需n-1条线路 问题转化为：如何在可能的线路中选择n-1条，能把 所有城市（顶点）均连起来，且总耗费 （各边权值之和）最小构造最小生成树方法普里姆(Prim)算法/T(n)=O(V²)算法思想： 设连通网N=(V,{E}),点集U为已处理点集，最小生成树边集TE。 初始任取一点，加入U，使U={v0}； 在所有u∈U,v∈V-U的边(u,v)∈E中，找一条代价最小的边(u0,v0) 两点确定一条边，即在所有生成树邻接的边里找条最小的。 将(u0,v0)并入集合TE，同时v0并入U 把边并入生成树，点并入已处理点集。 重复操作直至U=V。克鲁斯卡尔(Kruskal)算法/O(E log E)算法思想： 设连通网N=(V,{E})，初始状态为只有n个顶点而无边的非连通图T=(V,{∅})，每个顶点自成一个连通分量 在E中选取代价最小的边，若该边依附的顶点落在T中不同的连通分量上，则将此边加入到T中； 否则，舍去此边，选取下一条代价最小的边依此类推，直至T中所有顶点都在同一连通分量上为止。 一开始所有点各自独立，遍历E集合选代价最小边，若该边的两个顶点落在不同连通分量上，就加进T，直到T里所有顶点全在一个连通分量上。","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://daybreakland.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"图-3|图的遍历","slug":"7.3图的遍历","date":"2019-11-26T14:38:52.000Z","updated":"2019-11-27T09:18:05.263Z","comments":true,"path":"2019/11/26/7.3图的遍历/","link":"","permalink":"https://daybreakland.top/2019/11/26/7.3%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/","excerpt":"本篇记录了数据结构图这一章学习的第三部分，即图的遍历。","text":"本篇记录了数据结构图这一章学习的第三部分，即图的遍历。 深度优先遍历(DFS) 从图的某一顶点V0出发，访问此顶点；然后依次从V0的未被访问的邻接点出发，深度优先遍历图，直至图中所有和V0相通的顶点都被访问到；若此时图中尚有顶点未被访问，则另选图中一个未被访问的顶点作起点，重复上述过程，直至图中所有顶点都被访问为止 123456789101112131415161718192021222324//--- 下列算法使用的全局变量 ---Boolean visited[MAX]; // 访问标志数组Status (* VisitFunc)(int v); // 函数变量void DFS(Graph G, int v) &#123;// 从第v个顶点出发递归地深度优先遍历图G。 visited[v] = TRUE; VisitFunc(v); // 访问第v个顶点 for(w=FirstAdjVex(G,v);w!=0;w=NextAdjVex(G,v,w)) if(!visited[w]) DFS(G, w); // 对v的尚未访问的邻接顶点w递归调用DFS&#125;void DFSTraverse(Graph G, Status (*Visit)(int v)) &#123; // 对图G作深度优先遍历。 VisitFunc = Visit; for (v=0; v&lt;G.vexnum; ++v) visited[v] = FALSE; // 访问标志数组初始化 for (v=0; v&lt;G.vexnum; ++v) if (!visited[v]) DFS(G, v); // 对尚未访问的顶点调用DFS&#125; 广度优先遍历(BFS) 从图的某一顶点V0出发，访问此顶点后，依次访问V0的各个未曾访问过的邻接点；然后分别从这些邻接点出发，广度优先遍历图，直至图中所有已被访问的顶点的邻接点都被访问到；若此时图中尚有顶点未被访问，则另选图中一个未被访问的顶点作起点，重复上述过程，直至图中所有顶点都被访问为止 1234567891011121314151617181920void BFSTraverse( Graph G, status (*visit )(int v )) &#123; for( v = 0; v &lt; G.vexnum; ++v) visited[v] = FALSE; InitQueue( Q ); for( v = 0; v &lt; G.vexnum; ++ v) if( !visited[v] )&#123; visited[v] = TRUE; visit( v ); EnQueue( Q, v ); while( !QuqueEmpty( Q)) &#123; Dequeue( Q, u ); for(w=FirstAdjVex(G,u);w;w=NextAdjVex(G,u,w)) if( !Visited[w] )&#123; Visited[w]=TRUE; Visit( w ); Enqueue(Q,w); &#125;// if &#125;// while &#125;// if&#125;// BFSTraverse","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://daybreakland.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"图-2|图的存储结构","slug":"7.2图的存储结构","date":"2019-11-26T14:38:30.000Z","updated":"2019-11-28T04:00:16.958Z","comments":true,"path":"2019/11/26/7.2图的存储结构/","link":"","permalink":"https://daybreakland.top/2019/11/26/7.2%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/","excerpt":"本篇记录了数据结构图这一章学习的第二部分，即图的存储结构。","text":"本篇记录了数据结构图这一章学习的第二部分，即图的存储结构。 1.数组表示法(邻接矩阵表示)有向图的邻接矩阵表示：无向图中顶点Vi的度TD(Vi)是邻接矩阵A中第 i 行元素之和. 2.邻接表 无向图中顶点Vi的度为第i个单链表中的结点数 无向图的邻接表 有向图中顶点Vi的出度为第i个单链表中的结点个数顶点Vi的入度为整个单链表中邻接点域值是i的结点个数 逆邻接表：有向图中对每个结点建立以Vi为头的弧的单链表有向图的邻接表和逆邻接表 3.有向图的十字链表表示法十字链表是有向图的一种存贮方式其中，图中的顶点用顶点结点单元表示。弧用弧结点单元表示。 弧节点单元 tailvex / headvex: 尾/头域：弧尾和弧头两个顶点在图中的位置 hlink: 弧头相同的下一条弧 tlink: 弧尾相同的下一条弧 info: 该弧的相关信息顶点节点单元 firstin: 顶点为弧头的第一个弧结点；//可求入度 firstout: 顶点为弧尾的第一个弧结点；//可求出度 data: 该结点的相关信息表示样例对第一个结点而言，蓝色线串起了以1为弧头的弧，绿线串起了以1为弧尾的弧无向图邻接多重表表示法邻接多重表是无向图的一种存贮方式其中，图中的顶点用顶点结点单元表示。边用边节点单元表示。与邻接表的差别在于 ，邻接表用2个顶点表示一条边，而邻接多重表用1个顶点表示一条边。边节点单元 mark,访问标志； ivex/jvex:边依符的两个顶点的位置； ilink/jlink:两个顶点的下一条边； info:边的信息顶点节点单元表示样例","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://daybreakland.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Hexo+github搭建博客纪实","slug":"Hexo-github搭建博客纪实","date":"2019-11-25T14:57:23.000Z","updated":"2019-11-26T06:54:53.111Z","comments":true,"path":"2019/11/25/Hexo-github搭建博客纪实/","link":"","permalink":"https://daybreakland.top/2019/11/25/Hexo-github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%BA%AA%E5%AE%9E/","excerpt":"简单记述了搭建博客的过程，类似Debug的过程，马克了期间参考的资料，之后应该会持续更新功能。","text":"简单记述了搭建博客的过程，类似Debug的过程，马克了期间参考的资料，之后应该会持续更新功能。 Hexo+github搭建博客纪实一、注册github仓库二、环境搭建&#8195;1.下载node.js和git&#8195;&#8195;&#8195;git bash（用于授权SHH和安装hexo系列操作） &#8195;2.SHH授权&#8195;&#8195;&#8195;公钥与秘钥 三、Hexo系列操作&#8195;1.下载安装&#8195;2.初始化+本地预览&#8195;&#8195;&#8195;自然要换好看的主题 &#8195;3.上传到github四、域名转接&#8195;1.购买域名&#8195;2.在github设置domain五、搭建过程&#8195;1.参考教程 流程（系统）https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html#%E4%BD%BF%E7%94%A8hexo%E5%86%99%E5%8D%9A%E5%AE%A2 流程（易懂）https://www.cnblogs.com/trista222/p/8017300.html 域名绑定https://blog.csdn.net/mqdxiaoxiao/article/details/92799543&#8195;2.DebugERROR1 “the CNAME is already taken” 问题描述： 搭建完博客，每次更新之后，使用域名地址访问博客都会404报错并且github邮箱账户会收到一封Waring Email： The page build completed successfully, but returned the following warning for the ‘master’ branch:Your CNAME file was ignored because this repository is automatically hosted from yourUsername.github.io already. See https://help.github.com/articles/setting-up-your-pages-site-repository/For information on troubleshooting Jekyll see: https://help.github.com/articles/troubleshooting-jekyll-buildsIf you have any questions you can contact us by replying to this email. https://wangqy.cc/2018/05/26/CNAME/ 咱也不知道发生了啥，咱也不造去哪儿问，网上搜罗了下，发现了相同情况了老哥：https://wangqy.cc/2018/05/26/CNAME/原因是 setting 下 github pages 的 custom domain 清空了，需要重新设置来生成 CNAME 文件。我们的初步解决方案，便是每次更新完去github仓库的settings里把domain调成自己的域名。 然而人是贪婪的，也是懒的，次次更新次次调设置太繁琐了，于是又摸索了下，受名为saucxs的大佬文章启发：https://www.cnblogs.com/chengxs/p/7496265.html找到了进阶解决方案，修改_config.yml文件： `# URLurl: daybreakland.top【原来这里是“yourUsername.github.io”】root: /permalink: :year/:month/:day/:title/permalink_defaults:pretty_urls: trailing_index: true # Set to false to remove trailing index.html from permalinks 这样就算是彻底解决了问题。 &#8195;3.功能和技巧 19.11.23 插入图片https://blog.csdn.net/L_201607/article/details/81176439 19.11.23 插入占位符 123&amp;#8195;一个中文的占位符&amp;#8194;半个中文的占位符&amp;#8197;四分之一的中文占位符","categories":[],"tags":[]},{"title":"图-1|图的定义和术语","slug":"7.1图的定义和术语","date":"2019-11-25T13:18:14.000Z","updated":"2019-11-27T09:18:22.707Z","comments":true,"path":"2019/11/25/7.1图的定义和术语/","link":"","permalink":"https://daybreakland.top/2019/11/25/7.1%E5%9B%BE%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E6%9C%AF%E8%AF%AD/","excerpt":"本篇记录了数据结构图这一章学习的第一部分，即图的定义和术语。","text":"本篇记录了数据结构图这一章学习的第一部分，即图的定义和术语。 图的定义和术语有向图 顶点：数据 弧表示方法：&lt;v,w&gt;有序对 弧头 v 弧尾 w无向图 边 表示方法：（v,m）无序对&lt;&gt; 如何表示一个无向图？G1 =(V1 , {E1} )V1={v1,v2,v3,v4,v5} G1={ (v1,v2),(v2,v3),(v3,v4),(v3,v5),(v1,v4),(v2,v5) }图的抽象数据类型定义：123456ADT Graph&#123; 数据对象V：顶点集； 数据关系R：R=&#123;VR&#125; VR=&#123;&lt;v,w&gt;|v,w∈V,且P(v,w), &lt;v,w&gt;表示从v到w的弧， P(v,w)定义了弧&lt;v,w&gt;的意义或信息&#125;&#125; 图的基本操作1 CreateGraph(&amp;G, V, VR);初始条件：V是图的顶点集，VR是图中弧的集合操作结果：按V和VR的定义构造图G2 DestroyGraph(&amp;G);初始条件：图G存在操作结果：销毁图G3 LocateVex(G,u);初始条件：图G存在，u和G中顶点有相同特征操作结果：若G中存在顶点u，则返回该顶点在图中位置；否则返回其它信息。4 GetVex(G, v);初始条件：图G存在，v是G中某个顶点操作结果：返回v的值5 PutVex(&amp;G, v, value);初始条件：图G存在，v是G中某个顶点操作结果：对v赋值value6 FirstAdjVex(G, v);初始条件：图G存在，v是G中某个顶点操作结果：返回v的第一个邻接顶点。若顶点在G中没有邻接顶点，则返回“空”。7 NextAdjVex(G, v, w);初始条件：图G存在，v是G中某个顶点，w是v的邻接顶点。操作结果：返回v的（相对于w的）下一个邻接顶点。若w是v的最后一个邻接点，则返回“空”。8 InsertVex(&amp;G, v);初始条件：图G存在，v和图中顶点有相同特征。操作结果：在图G中增添新顶点v9 DeleteVex(&amp;G, v);初始条件：图G存在，v和图中顶点有相同特征操作结果：删除G中顶点v及相关的弧10 InsertArc(&amp;G, v, w); 初始条件：图G存在，v和w是G中两个顶点。 操作结果：在G中增添弧&lt;v,w&gt;，若G是无向的，则还增添对称弧&lt;w,v&gt;11 DeleteArc(&amp;G, v, w); 初始条件：图G存在，v和w是G中两个顶点。 操作结果：在G中删除弧&lt;v,w&gt;，若G是无向的，则还删除对称弧&lt;w,v&gt;12 DFSTraverse(G, v, Visit( )); 初始条件：图G存在，v是G中某个顶点，Visit是顶点的应用函数。 操作结果：从顶点v起深度优先遍历图G，对每个顶点调用函数Visit一次且仅一次。一旦visit( )失败，则操作失败13 BFSTraverse(G, v, Visit( )); 初始条件：图G存在，v是G中某个顶点，Visit是顶点的应用函数。 操作结果：从顶点v起广度优先遍历图G，对每个顶点调用函数Visit一次且一次。一旦visit( )失败，则操作失败子图 设有两个图G =（V,E）G1 =（V1,E1）,若V1∈V,E1 ∈ E,则称 G1是G的子图； 编辑器打不出集合包含符号，先用∈代替 常见的图 1.有向完全图n个顶点的有向图最大边数是n(n-1) 2.完全图n个顶点的无向图最大边数是n(n-1)/2 3.稀疏图/稠密图边数少为前者，多为后者 4.权与图的边或弧相关的数为权 5.网带权的图顶点的度 无向图中，顶点的度为与每个顶点相连的边数 有向图中，顶点的度分成入度与出度 入度：以该顶点为头的弧的数目 出度：以该顶点为尾的弧的数目 邻接点 对于无向图G=(V,{E})，如果边 (v,v’)∈E，则称顶点v和v’互为邻接点(Adjacent)，即v和v’相邻接。边(v,v’) 依附(Incident) 于顶点v和v’或者说 (v,v‘)和顶点v和v’相关联。 对于有向图G=(V,{A}))，如果弧&lt;v,v’&gt;∈A，则称顶点v邻接到顶点v’,顶点v’邻接自顶点v，弧&lt;v,v’&gt;和顶点v,v’相关联**。 路径两个顶点之间的顶点序列，该序列的每个顶点与其前驱是邻接点，每个顶点与其后继也是邻接点 路径长度——沿路径边的数目或沿路径各边权值之和 回路——第一个顶点和最后一个顶点相同的路径叫~ 简单路径——序列中顶点不重复出现的路径叫~ 简单回路——除了第一个顶点和最后一个顶点外，其余顶点不重复出现的回路叫~ 连通图（强连通图） 无向图中，若任意两点都存在路径，此图是连通图。 有向图中，若任意两点都存在互通路径，此图是强连通图。 连通分量无向图G的极大连通子图成为G的连通分量。 极大连通子图：该子图是G连通子图，将G的任何不在该子图中的顶点加入，子图不再连通。 强连通分量有向图D的极大强连通子图成为D的强连通分量。 极大强连通子图意思是：该子图是D强连通子图，将D的任何不在该子图中的顶点加入，子图不再是强连通的。 下面总结了如何判断连通子图是不是极大或极小连通子图。（这个问题好像在离散数学提到过） 若在一个连通子图中，包含了与其中顶点有关所有边（the more the better），则是极大连通子图；若只包含了必不可少的边（the less the better），那就是极小连通子图。 关于此概念，下面的博文讲的很好，上面的总结也是受教于这位博主。原文链接：https://blog.csdn.net/merlyn_yang/article/details/82467980 版权声明：本文为CSDN博主「merlyn_yang」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。 生成树 包含无向图G所有顶点的的极小连通子图称为G生成树。它含有图中全部顶点，但只有足以构成一棵树的n-1条边。一棵有n个顶点的生成树有且仅有n-1条边。","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://daybreakland.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"枕草子","slug":"枕草子-春曙为最","date":"2019-11-23T09:05:52.000Z","updated":"2019-11-25T14:27:54.359Z","comments":true,"path":"2019/11/23/枕草子-春曙为最/","link":"","permalink":"https://daybreakland.top/2019/11/23/%E6%9E%95%E8%8D%89%E5%AD%90-%E6%98%A5%E6%9B%99%E4%B8%BA%E6%9C%80/","excerpt":"","text":"清少纳言随笔《枕草子》的第一篇，恬淡自由，勾勒出四时之美。 まくらのそうし·春はあけぼの &#8195;春は、あけぼの。やうやう白くなりゆく、山ぎは少し明りて、紫だちたる雲のほそくたなびきたる。 夏は、夜。月のころはさらなり、闇もなほ、蛍の多く飛びちがひたる。また、ただ一つ二つなど、ほのかにうち光りて行くも、をかし。雨など降るも、をかし。 秋は、夕暮れ。夕日のさして、山の端いと近うなりたるに、烏の寝どころへ行くとて、三つ四つ、二つ三つなど、飛び急ぐさへあはれなり。まいて、雁などのつらねたるが、いと小さく見ゆるは、いとをかし。日入り果てて、風の音、虫の音(ね)など、はた言ふべきにあらず。 冬は、つとめて。雪の降りたるは言ふべきにもあらず。霜のいと白きも、またさらでも、いと寒きに、火など急ぎおこして、炭持て渡るも、いとつきづきし。昼になりて、ぬるくゆるびもていけば、火桶の火も白き灰がちになりて、わろし。 枕草子·春曙为最 &#8195;春，曙为最。逐渐转白的山顶，开始稍露光明，泛紫的细云轻飘其上。 &#8195;夏则夜。有月的时候自不待言，无月的暗夜，也有群萤交飞。若是下场雨什么的，那就更有情味了。 &#8195;秋则黄昏。夕阳照耀，近映山际，乌鸦返巢，三只、四只、两只的飞过，平添感伤。又有时见雁影小小，列队飞过远空，尤绕风情。而况，日入以后，尚有风声虫鸣。 &#8195;冬则晨朝。降雪时不消说，有时霜色皑皑，即使无雪亦无霜，寒气凛冽，连忙生一盆火，搬运炭火跑过走廊，也挺合时宜；只可惜晌午时分，火盆里头炭木渐蒙白灰，便无甚可赏了。 翻译来源：《枕草子》（清少纳言著，林月文译）原文来源：http://www.eonet.ne.jp/~log-inn/03honkan.htm","categories":[],"tags":[{"name":"摘抄","slug":"摘抄","permalink":"https://daybreakland.top/tags/%E6%91%98%E6%8A%84/"}]},{"title":"论文Introduction改写","slug":"hello-world","date":"2019-11-22T12:13:32.936Z","updated":"2019-12-03T05:09:14.385Z","comments":true,"path":"2019/11/22/hello-world/","link":"","permalink":"https://daybreakland.top/2019/11/22/hello-world/","excerpt":"","text":"提要：论文Introduction部分还是简洁为妙。 其中，尤其是需要答辩的论文，毕竟答辩期间Introduction部分时间占比是相当之少的。所以改写版本相比原版删去或整合了很多内容，希望没有改变作者原本的意思。 同时，由于这一部分的本意是阐述写作目的，提出问题并强调研究意义，其中要描述本领域研究现状，又要突出强调自己研究的拓展、创新之处，为正文的论述做准备，所以语句应尽量做到不拖泥带水，过渡和转折到位，充分为正文蓄势。Introduction 简洁地交代下背景&amp;&amp;现状 Since the discovery of X rays in 1895,radiation has been shrouded in myths and partly as a doomsday power destined to cause the ultimate destruction of mankind. In our own time, fear seems to be the prevalent characteristic of the public perception of radiation phenomena, and the treatment in the media of incidents like the Chernobyl accident has greatly contributed to the spreading of uneasiness and fear. 结合背景，交代下写作目的 Due to above background, the general public’s perception towards radiation is mostly shallow, for most of them are lacking of basic knowledge of radiation. Why should we expect the public to know something about radioactivity and radiation? Three of the most evident answers are the following: The pragmatic reasonPeople should be capable of protecting themselves from the harmful effects of radiation as well as avoiding excessive fear. The democratic reasonPeople should be capable of informed judgements in political matters involving radiation phenomena, nuclear energy, waste disposal, exposure limit etc. The educational reasonThe individual derives pleasure and fulfillment from knowing something about the world around him/her. 介绍相关问题地研究状况，指出他人局限，强调本篇地研究更具有意义和代表性 A critical task is to detect how much understanding the mass have about the radioactivity and radiation via doing a systematic investigation and study. For instant, Lijnse et al. described concepts of radioactivity and radiation held by 15- and 16-year-old pupils in the Netherlands, and Eijkelhof and Millar analyzed British newspaper reports of the Chernobyl accident to identify features of the lay understanding of radiation phenomena. However, today we are to focus on doing a survey on a rather more typical and representative group, which the previous research didn’t perform so well. 本篇调查方式和主体简介，引入正文 The present survey was conducted to investigate the understanding of radiation phenomena and risk among Norwegians with a reasonable level of general education, but lacking specialization in physical science.","categories":[],"tags":[]}]}