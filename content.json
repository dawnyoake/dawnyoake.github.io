{"meta":{"title":"夜明的Blog","subtitle":"Daybreak","description":"Where would a south wind take us","author":"夜明","url":"https://daybreakland.top","root":"/"},"pages":[],"posts":[{"title":"数据结构 | 串，数组和广义表","slug":"5-0、6-0-串，数组和广义表","date":"2019-12-13T01:53:17.000Z","updated":"2019-12-13T01:55:27.941Z","comments":true,"path":"2019/12/13/5-0、6-0-串，数组和广义表/","link":"","permalink":"https://daybreakland.top/2019/12/13/5-0%E3%80%816-0-%E4%B8%B2%EF%BC%8C%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/","excerpt":"串的基本概念，存储方式、模式匹配算法广义表的表长、表头表尾、链式存储","text":"串的基本概念，存储方式、模式匹配算法广义表的表长、表头表尾、链式存储 串是以字符为元素的线性表4.1 串类型的定义4.2 串的表示和实现 4.2.1 定长顺序存储表示 4.2.2 堆分配存储表示4.3 串的模式匹配算法 串串类型的定义基本概念串(字符串 string)：由零个或多个字符组成的有限序列记为: s =‘a1a2…an’ (n ≥ 0) ai(1≤i≤n)是字母,数字或其它字符 串名： s为串名 串值：‘a1a2…an’为串值 长度：n称为串的长度 空串：n=0的串称为空串(Null string)记为：Ф 空白串:通常将仅由一个或多个空格组成的串称为空白串(Blank String) 注意：空串和空白串的不同，例如“ ”和“”分别表示长度为1的空白串和长度为0的空串。子串：串中任意个连续字符组成的序列； 位置：字符在序列中的序号 子串的位置：子串第一个字符在主串中的位置 ADT123456789101112131415161718192021222324252627282930313233343536373839404142ADT String &#123;数据对象：D = &#123;ai | ai∈CharacterSet,i=1,2,...n, n&gt;=0&#125;数据关系： R1= &#123;&lt;ai-1., aj&gt;| ai ∈D, i=2,...n&#125;。基本操作： StrAssign(&amp;T,chars) 初始条件: chars是字符串常量。 操作结果: 生成一个其值等于chars的串T。 StrCopy(&amp;T,S) 初始条件: 字符串S已经存在。 操作结果: 由串S复制得串T。 StrEmpty (S) 初始条件: 字符串S已经存在。 操作结果: 若S为空串，则返回TRUE,否则返回FALSE。 StrCompare(S,T) 初始条件: 字符串S和T存在。 操作结果: 若S&gt;T,则返回值&gt;0;若S=T,则返回值=0;否则返回值&lt;0。 StrLength(S) 初始条件: 字符串S已经存在。 操作结果: 返回串S元素个数，称为串的长度。 ClearString(&amp;S) 初始条件: 字符串S已经存在。 操作结果: 将串S清为空串。 Concat(&amp;T,S1,S2) 初始条件: 字符串S1,S2已经存在。 操作结果: 用T返回由串S1和S2联结而成的新串。 Substring(&amp;Sub,S,pos,len) 初始条件: 串S存在,1&lt;=pos&lt;=S的长度,0&lt;=len&lt;=S的长度-pos+1。 操作结果: 用Sub返回串S的第pos个字符起长度为len的子串。 Index(S,T,pos) 初始条件: 串S和T存在,T是非空串，1&lt;=pos&lt;=S的长度。 操作结果: 若主串S中存在和串T相同的子串，则返回它在主串S中第pos个字符之后第一次出现的位置；否则返回０。 Replace(&amp;S,T,V) 初始条件: 字符串S,T,V已经存在，T是非空串。 操作结果: 用V替换主串S中出现的所有与T相等的不重叠的子串。 StrInsert(&amp;S,pos,T) 初始条件: 字符串S,T存在，1&lt;=pos&lt;=S的长度+1。 操作结果: 在串S的第pos个字符之前插入串T。 StrDelete(&amp;S,pos,len) 初始条件: 串S存在，1&lt;=pos&lt;=S的长度-len+1。 操作结果: 从串S中删除第pos个字符起长度为len的子串。 DestroyString(&amp;S): 把存在的串S销毁。&#125;ADT String 串类型的最小操作子集 下面5种操作构成最小操作子集:串赋值 StrAssign;串比较 StrCompare;求串长 StrLength;串联结 Concat;求子串 Substring; 串的表示和实现顺序表示定长顺序表示用连续的存储单元存储串,存储单元的长度固定。 堆分配存贮表示特点：仍用连续的存储单元存储串，但存储空间是在程序执行过程中动态分配而得。 链式表示块链存贮表示一个结点的数据域不仅放一个数据元素（字符），而是放多个数据元素。 串的模式匹配算法求子串位置的定位函数:子串的定位操作通常称作串的模式匹配（其中T被称模式串），是各种串处理系统中最重要的操作之一。 算法分析设n = StrLength(S);m = StrLength(T); 最好情况的复杂度为O(n+m)；最坏情况的复杂度为O(n*m)。 KMP算法模式匹配的一种改进算法KMP算法的改进在于: 每一趟匹配过程中出现字符比较不等时,不需要回朔i指针 只要利用已经“部分匹配”结果,调整j指针,即将模式向右滑动尽可能远的一段距离,来个提高算法效率. 数组和广义表定义数组可以看成是一种特殊的线性表，即线性表中数据元素本身也是一个线性表。 ADT1234567891011121314151617ADT Array&#123; 数据对象：D=&#123;aj1j2…jn|n(&gt;0)称为数组的维数， bi 是数组第i维的长度 ji 是数组元素的第i维下标， ji = 0, …, bi – 1, i = 1, 2, …, n， aj1j2…jn ∈ ElemSet &#125; 数据关系：R = &#123;R1, R2, … Rn&#125; Ri = &#123; &lt;a j1…ji…jn, aj1…ji+1…jn&gt;| 0≤jk ≤ bk-1, 1 ≤k ≤n 且k ≠i, 0 ≤ji ≤bi –2, aj1…ji…jn, aj1…ji+1…jn ∈ D, i = 2, …, n &#125; 基本操作: InitArray(&amp;A,n,b1,…，bn ); // 初始化 DestroyArray(&amp;A ); // 销毁 Value( A, &amp;e, i1, i2, … in); // 取值 Assign( &amp;A, e, i1, i2, … in); // 赋值&#125;// Array 数组的顺序存储结构主序存放 按列序为主序存放 按行序为主序存放n维数组的存储地址计算公式矩阵的压缩存储 矩阵: 二维数组 特殊矩阵: 大量重复元素或大量0元素 稀疏矩阵: 大量0元素 压缩存储: 重复元素只分配一个存储空间,0元素不分配存储空间 对称矩阵 三角矩阵 下三角矩阵 对角矩阵 稀疏矩阵 定义：非零元素较少，且分布没有一定规律的矩阵 压缩存储原则：只存矩阵的行列维数和每个非零元素的行列下标及其值 通常稀疏因子&lt;0.05时称为稀疏矩阵 稀疏矩阵的压缩存储方法顺序存储结构：三元组表链式存储结构：十字链表 广义表定义 广义表：LS = ( α1, α2, … αn) αi 可以是单个数据元素，也可以是广义表。 广义表是由n个数据元素构成的一个表，其数据元素可以是单个数据元素，也可以是一个广义表。 n 长度;若αi为单个元素，称为原子；否则子表α1为表头，其余元素组成的表为表尾表长最大括号内的逗号数+1特别地，E = ( a, E ); 递归表，长度为2广义表的链式存储结构广义表不能使用顺序存储，只能链式存储。","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://daybreakland.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构 | 内部排序","slug":"10.0内部排序","date":"2019-12-08T16:39:58.000Z","updated":"2019-12-09T01:48:33.775Z","comments":true,"path":"2019/12/09/10.0内部排序/","link":"","permalink":"https://daybreakland.top/2019/12/09/10.0%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F/","excerpt":"插入排序、选择排序、希尔排序、快速排序、堆排序、归并排序、基数排序。","text":"插入排序、选择排序、希尔排序、快速排序、堆排序、归并排序、基数排序。 主要内容10.1 概述10.2 插入排序 10.2.1 直接插入排序 10.2.2 折半插入排序 10.2.3 shell排序10.3 交换排序（快速排序）10.4 选择排序 10.4.1 简单选择排序 10.4.3 堆排序10.5 归并排序10.6 基数排序10.7 各种排序方法的比较讨论 概述排序定义将一个数据元素（或记录）的任意序列，重新排列成一个按关键字有序的序列叫~ 排序分类 按待排序记录所在位置内部排序：待排序记录存放在内存外部排序：排序过程中需对外存进行访问的排序 按排序依据原则插入排序：直接插入排序、折半插入排序、希尔排序交换排序：冒泡排序、快速排序选择排序：简单选择排序、堆排序归并排序：2-路归并排序基数排序 按排序所需工作量简单的排序方法：T(n)=O(n²)先进的排序方法：T(n)=O(logn)基数排序：T(n)=O(d.n) 排序基本操作比较两个关键字大小将记录从一个位置移动到另一个位置 稳定排序与不稳定排序 关键码相同的数据对象在排序过程中是否保持前后次序不变。如 2, 2,1，排序后若为1, 2, 2 则该排序方法是不稳定的。 插入排序直接插入排序整个排序过程为n-1趟插入，即先将序列中第1个记录看成是一个有序子序列，然后从第2个记录开始，逐个进行插入，直至整个序列有序。 算法实现1234567891011Void InsertSort(SqList &amp; L)&#123; for (i= 2; i&lt; L.Length; ++i ) if LT(L.r[i].key,L.r[i-1].key)&#123; //需将L.r[i] 插入有序表） L.r[0]= L.r[i]; //设置监视哨 L.r[i]= L.r[i-1]; for (j=i-2;LT(L.r[0].key,L.r[j].key);--j) L.r[j+1]=L.r[j] ;//记录向后移动 L.r[j+1]= L.r[0];//将L.r[i]插入正确位置 &#125;&#125; InsertSort 算法评价时间复杂度：T(n)=O(n^2^)空间复杂度：S(n)=O(1)直接插入排序是一种稳定的排序方法。因为关键码相同的两个对象，在整个排序过程中，不会通过比较而相互交换。 折半插入排序用折半查找方法确定插入位置的排序叫折半插入排序。 算法实现12345678910111213141516Void BInsertSort(SqList &amp; L) &#123; for (i=2; i&lt;= L.length;++i)&#123; L.r[0]=L.r[i]; （将L. r [i]暂存到L. r [0]） low=1; high=i–1; while(low&lt;= high) &#123; （在子表中查找插入位置） m=(low+high)/2; if LT(L.r[0].key,L.r[m].key) high=m-1;（插入点在低半区） else low=m+1; （插入点在高半区） &#125; //while for(j=i-1;j&gt;=high+1;--j) L.r[j+1] = L.r[j] ;（记录后移） L.r[high+1] = L.r[0]; （插入记录） &#125; //for&#125; 算法评价时间复杂度：T(n)=O(n²)空间复杂度：S(n)=O(1)折半插入排序是一种稳定的排序方法。 希尔排序(缩小增量法)它属于插入排序类的方法。 基本思想先将整个待排序的记录分割成若干子序列分别进行直接插入排序，待整个序列中的记录”基本有序“时，再对全体记录进行一次直接插入排序。 排序过程先取一个正整数d1&lt;n，把所有相隔d1的记录放一组，组内进行直接插入排序；然后取d2&lt;d1，重复上述分组和排序操作；直至di=1，即所有记录放进一个组中排序为止。 算法实现123456789101112131415Void ShellInsert(SqList &amp;L,int dk)&#123; //dk为跨度,r[0]是暂存单元,j&lt;=0,插入位置已找到 for(i=dk+1;i&lt;=L.length;++i) if LT(L.r[i].key,L.r[i–dk].key)&#123;//L.r[i]为待排序记录 L.r[0]=L.r[i];//将L.r[i]暂存到L.r[0] for(j=i–dk;j&gt;0&amp;&amp;LT(L.r[0].key,L.r[j].key);j-=dk) L.r[j+dk]=L.r[j];//将大于插入值的记录向后移动 L.r[j+dk]=L.r[0];//插入 &#125;&#125;ShellInsertvoid ShellSort(SqList &amp;L,int dita[], int t)&#123; //dita[0…t-1]存放跨度的数组 for(k=0;k&lt;t;++k) ShellInsert(L,dita[k]);//由dita[k]得到跨度&#125;ShellSort 希尔排序特点 子序列的构成不是简单的“逐段分割”，而是将相隔某个增量的记录组成一个子序列 希尔排序可提高排序速度，因为 分组后n值减小，n²更小，而T(n)=O(n²),所以T(n)从总体上看是减小了 关键字较小的记录跳跃式前移，在进行最后一趟增量为1的插入排序时，序列已基本有序 增量序列取法 无除1以外的公因子 最后一个增量值必须为1 交换排序冒泡排序基本思想将第一个记录的关键字与第二个记录的关键字进行比较，若为逆序r[1].key&gt;r[2].key，则交换；然后比较第二个记录与第三个记录；依次类推，直至第n-1个记录和第n个记录比较为止——第一趟冒泡排序，结果关键字最大的记录被安置在最后一个记录上 对前n-1个记录进行第二趟冒泡排序，结果使关键字次大的记录被安置在第n-1个记录位置 重复上述过程，直到“在一趟排序过程中没有进行过交换记录的操作”为止 算法评价时间复杂度：T(n)=O(n²)空间复杂度：S(n)=O(1) 快速排序基本思想通过一趟排序，将待排序记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录进行排序，以达到整个序列有序。排序过程对r[s……t]中记录进行一趟快速排序，附设两个指针i和j，设枢轴记录rp=r[s]，x=rp.key。 初始时令i=s,j=t 首先从j所指位置向前搜索第一个关键字小于x的记录，并和rp交换 再从i所指位置起向后搜索，找到第一个关键字大于x的记录，和rp交换 重复上述两步，直至i==j为止 再分别对两个子序列进行快速排序，直到每个子序列只含有一个记录为止 算法实现1234567891011121314Int Partition( SqList &amp; L, int low, int high)&#123; L.r[0]=L.r[low]; pivotkey=L.r[low].key; while(low&lt;high)&#123; while(low&lt;high&amp;&amp;L.r[high].key&gt;=piotkey) --high; L.r[low]=L.r[high]; while (liw&lt;high&amp;&amp;L.r[low].key&lt;=pivotkey) ++low; L.r[high]=L.r[low]; &#125; L.r[high]=L.r[0]; return low;&#125; 算法评价时间复杂度最好情况（每次总是选到中间值作枢轴）T(n)=O(nlogn)最坏情况（每次总是选到最小或最大元素作枢轴）T(n)=O(n²)空间复杂度需栈空间以实现递归最坏情况：S(n)=O(n)一般情况：S(n)=O(logn) 选择排序是每一趟在n-i+1(i= 1,2,3…n-1)个记录中选择关键字最小的记录作为有序序列中第i个记录。 简单选择排序排序过程首先通过n-1次关键字比较，从n个记录中找出关键字最小的记录，将它与第一个记录交换再通过n-2次比较，从剩余的n-1个记录中找出关键字次小的记录，将它与第二个记录交换重复上述操作，共进行n-1趟排序后，排序结束。 算法实现1234567void SelectSort(SqList&amp;L ) for(i=1;i&lt;L.length;++i) &#123; j =SelectMinkey(L,i); if (i!=j) L.r[i]↔L.r[j]; &#125;&#125; 堆排序堆的定义n个元素的序列(k1,k2,……kn)，当且仅当满足下列关系时，称之为堆可将堆序列看成完全二叉树，则堆顶元素（完全二叉树的根）必为序列中n个元素的最小值或最大值。 堆排序基本思想将无序序列建成一个堆，得到关键字最小（或最大）的记录；输出堆顶的最小（大）值后，使剩余的n-1个元素重又建成一个堆，则可得到n个元素的次小值；重复执行，得到一个有序序列，这个过程叫堆排序。堆排序需解决的两个问题：1.如何由一个无序序列建成一个堆？ 方法：从无序序列的第floor(n/2)个元素（即此无序序列对应的完全二叉树的最后一个非终端结点）起，至第一个元素止，进行反复筛选 2.如何在输出堆顶元素之后，调整剩余元素，使之成为一个新的堆？ 筛选方法：输出堆顶元素之后，以堆中最后一个元素替代之；然后将根结点值与左、右子树的根结点值进行比较，并与其中小者进行交换；重复上述操作，直至叶子结点，将得到新的堆，称这个从堆顶至叶子的调整过程为“筛选”。 堆排序的算法123456789101112131415161718192021Type SqList HeapType;Void HeapAdjust(HeapType &amp; H, int s,int m) &#123; rc = H.r[s]; for (j=2*s;j&lt;=m;j*=2)&#123; if (j&lt;m&amp;&amp;LT(H.r[j].key,H.r[j+1].key )) ++j; if( !LT( rc.key, H.r[j].key)) break; H.r[s]=H.r[j]; s=j; &#125; H.r[s]=rc;&#125;Void HeapSort(HeapType &amp; H )&#123; for (i= H.length/2; i&gt;0 ;--i)（从最下层的分支结点向上） HeapAdjust (H,i,H.length); for (i= H.length; i&gt;1 ; --i )&#123; H.r[1] ↔ H.r[i] ; HeapAdjust( H, 1, i-1);（从根结点向下） &#125;&#125; 算法评价时间复杂度：最坏情况下T(n)=O(nlogn)空间复杂度：S(n)=O(1) 归并排序将两个或两个以上的有序表组合成一个新的有序表 2-路归并排序排序过程设初始序列含有n个记录，则可看成n个有序的子序列，每个子序列长度为1两两合并，得到n/2个长度为2或1的有序子序列再两两合并，……如此重复，直至得到一个长度为n的有序序列为止 算法实现123456789101112131415161718192021void Merge(RcdType SR[ ],RcdType &amp;TR[ ],inti, int m, int n) &#123; for (j = m+1,k =i; i&lt;= m &amp;&amp; j&lt;= n; ++ k)&#123; （m为i的上限，m+1为j的下限） if LQ(SR[i].key,SR[j].key) TR[K] = SR[i++]; else TR[k] = SR[j ++] &#125; if (i&lt;= m )TR[k…n] = SR[i…m]; if (j&lt;= n )TR[k…n] = SR[j…n];&#125;Void Msort (RcdType SR[ ],RcdType&amp;TR1[ ],int s,int t) &#123; if (s = t) TR1[s] = SR[s]; else &#123; m = (s + t )/2; ( 将SR[s…t ]平分为 SR[s…m]和 SR[m+1…t ] ) Msort( SR,TR2,s,m); (递归地将SR[s…m] 归并为有序的TR 2[s…m] Msort( SR,TR2, m+1,t ); (递归地将SR[m+1…t ]归并为有序的TR2[m+1…t] ） Merge(TR2,TR1,s,m,t); (将TR2[m+1..t] 和 TR2[M+1..T]归并到TR1[s..t] ） &#125;&#125;Void MergeSort( SQList &amp; L)&#123; Msort (L.r,L.r, 1, L.length);&#125; 算法评价MergeSort调用 log2n 次，总的时间复杂度为O(n log2n)空间开销为需要一个与原待排序对象数组同样大小的辅助数组。 迭代的归并排序是稳定的排序方法。 基数排序多关键字排序方法 最高位优先法（MSD)先对最高位关键字k1（如花色）排序，将序列分成若干子序列，每个子序列有相同的k1值；然后让每个子序列对次关键字k2（如面值）排序，又分成若干更小的子序列；依次重复，直至就每个子序列对最低位关键字kd排序；最后将所有子序列依次连接在一起成为一个有序序列 最低位优先法(LSD)从最低位关键字kd起进行排序，然后再对高一位的关键字排序，……依次重复，直至对最高位关键字k1排序后，便成为一个有序序列","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://daybreakland.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构 | 查找","slug":"9.0查找","date":"2019-12-08T03:39:58.000Z","updated":"2019-12-09T01:46:21.322Z","comments":true,"path":"2019/12/08/9.0查找/","link":"","permalink":"https://daybreakland.top/2019/12/08/9.0%E6%9F%A5%E6%89%BE/","excerpt":"静态查找表：顺序查找和折半查找；动态查找表：二叉排序树、二叉平衡树、B/B+树、哈希查找、哈希表","text":"静态查找表：顺序查找和折半查找；动态查找表：二叉排序树、二叉平衡树、B/B+树、哈希查找、哈希表 主要内容 9.1 静态查找表 9.1.1 顺序表的查找 9.1.2 有序表的查找 9.2 动态查找表 9.2.1 二叉排序树和二叉平衡树 9.2.2 B_树和B+树//本篇文章此处截止 9.3 哈希( Hashing )表(散列表) 参考资料：B树部分大面积整理使用了这位文哥的资料，前辈总结的真的特别好，这里直接使用了……侵删。作者：文哥的学习日记链接：https://www.jianshu.com/p/7dedb7ebe033 概 述 查找表 (search table):同一类型数据元素构成的集合。 查找操作:(1)查询某个“特定的”数据元素是否在查找表中;(2)检索某个“特定的”数据元素的各种属性;(3)在查找表中插入一个数据元素;(4)从查找表中删除某个数据元素. 静态查找表：对查找表只作(1)、(2)操作；动态查找表：可以对查找表作(1)-(4)操作。 查找方法评价 1.查找速度2.占用存储空间多少3.算法本身复杂程度4.平均查找长度ASL(Average Search Length)：为确定记录在表中的位置，需和给定值进行比较的关键字的个数的期望值叫查找算法的ASL。 静态查找表定义只提供如下两种查找的查找表: 1） 查询某个“特定”元素是否在表中； 2） 检索某个“特定”元素的各种属性； 顺序表及其查找 —— 顺序查找法查找表组织查找表用线性表表示。即将查找表的记录排成一个记录序列（无序）。L1=(45,53,12,3,37,24,100,61,90,78) 1234typedef struct&#123; //静态查找表的顺序存储结构 ElemType *elem; int length;&#125;SSTable; 顺序查找查找过程：从表的一端开始逐个进行记录的关键字和给定值的比较 逐一比较，且设置0号位置为监视哨，0处值等于待查找值。 顺序查找的性能分析平均查找长度ASLss=（n+1）/2 顺序查找的算法12345678int Search_Seq(SSTable ST, KeyType key)&#123; //在顺序表ST中顺序查找其关键字等于key的数据元素。 //若找到，则函数值为该元素在表中的位置，否则为0。 ST.elem[0].key=key; // “哨兵” for(i=ST.length;!EQ(key,ST.elem[mid].key);--i) //从后向前找 return i; //若表中不存在待查元素，i=0 &#125;//Search_Seq 有序表及其查找 —— 折半查找法 有序表若线性表中的记录按关键字有序，则称为有序表查找表组织查找表用有序表表示。即将查找表的记录排成按关键字有序的序列。折半查找 查找过程：每次将待查记录所在区间缩小一半 适用条件：采用顺序存储结构的有序表 算法实现设表长为n，low、high和mid分别指向待查元素所在区间的上界、下界和中点,k为给定值初始时，令low=1,high=n,mid=floor[(low+high)/2]让k与mid指向的记录比较:若k==r[mid].key，查找成功;若k&lt;r[mid].key，则high=mid-1;若k&gt;r[mid].key，则low=mid+1;重复上述操作，直至low&gt;high时，查找失败.折半查找的性能分析查找过程中所有元素可构成一颗判定二叉树，例如： 判定树上每个结点需要的查找次数刚好为该结点所在的层数. 无论查找成功或失败，次数不会超过判定树的深度 n个结点的判定树的深度为[log2n]+1 折半查找的算法复杂度不超过[log2n]+1 查找成功时的平均查找长度ASLbs= log2(n+1)-1 折半查找的算法123456789101112131415int Search_Bin ( SSTable ST, KeyType key ) &#123; // 在有序表ST中折半查找其关键字等于key的数据元素。// 若找到，则函数值为该元素在表中的位置，否则为0。 low=1;high=ST.length; // 置区间初值 while (low&lt;=high) &#123; mid=(low+high)/2; if（EQ(key,ST.elem[mid].key)) return mid; // 找到待查元素 else if (LT(key,ST.elem[mid].key)) high = mid - 1; // 继续在前半区间进行查找 else low = mid + 1; // 继续在后半区间进行查找 &#125; return 0; // 顺序表中不存在待查元素&#125; // Search_Bin 分块查找 —— 索引顺序查找查找表组织分块有序表 索引顺序查找查找过程将表分成几块，块内无序，块间有序；先确定待查记录所在块，再在块内查找。 索引顺序查找的性能分析 索引顺序查找的算法实现该表的构造过程是：把要查找的表分成长度相等的几个子表（称为块）。对每个子表建立一个索引项。索引表中关键字递增有序，具体表块内部记录可以无序。但块之间一定有序（即后一块中的最小关键字都大于前一块中最大关键字）。查找过程分两步：1.首先在索引表中确定待查记录所在的块；2.在块中按顺序查找。注意，索引表有序且是顺序存储结构中可以用折半查找。块中记录无序只能用顺序查找。 查找方法比较 顺序查找 折半查找 分块查找 ASL 最大 最小 中间 表结构 有序/无序 有序 分块有序 存储结构 顺序存储结构/线性链表 顺序存储 顺序存储结构/线性链表 动态查找表定义静态以外，额外提供查找后的插入和删除操作。 二叉排序树定义 二叉排序树或是一棵空树，或是具有下列性质的二叉树： 1.若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值2.若它的右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值3.它的左、右子树也分别为二叉排序树 二叉排序树的插入（生成） 插入原则若二叉排序树为空，则插入结点应为新的根结点；否则，继续在其左、右子树上查找，直至某个叶子结点的左子树或右子树为空为止，则插入结点应为该叶子结点的左孩子或右孩子 二叉排序树生成从空树出发，经过一系列的查找、插入操作之后，可生成一棵二叉排序树 查找算法一12345678910//在根指针T所指二叉排序树中递归地查找某关键字等于key的数据元素，//若查找成功，则返回指向该数据元素结点的指针,否则返回空指针。BiTree SearchBST(BiTree T,KeyType key)&#123; if(!T)||EQ(key,T-&gt;data.key)) return(T); else if LT(key, T-&gt;data.key) //查找的值比当前节点小 return(SearchBST(T-&gt;lchild,key)); else return(SearchBST(T-&gt;rchild.key));&#125;//SearchBST 查找算法二12345678910111213//在根指针T所指二叉排序树中递归地查找其关键字等于key的数据元素，若查找//成功，则指针p指向该数据元素结点，并返回TRUE，否则指针p指向查找路径上//访问的最后一个结点并返回FALSE,指针f指向T的双亲，其初始调用值为NULLStatus SearchBST(BiTree T,KeyType key,BiTree f,BiTree &amp;p)&#123; if(!T) &#123;p=f;return FALSE;&#125; else if EQ(key,T-&gt;data.key) &#123; p=T;return TRUE;&#125; else if LT(key,T-&gt;data.key)//每一步查找记录cur的双亲，即把T赋给下一个f SearchBST(T-&gt;lchild,key,T,p); else SearchBST(T-&gt;rchild,key,T,p);&#125;//SearchBST 插入算法1234567891011121314151617// 当二叉排序树T中不存在关键字等于e.key的数据元素时，插入e并返回TRUE，// 否则返回FALSE。Status InsertBST(BiTree &amp;T,ElemType e)&#123; if(!SearchBST(T, e.key, NULL, p)&#123; s=(BiTree)malloc(sizeof(BiTNode)); s-&gt;data=e; s-&gt;lchild=s-&gt;rchild=NULL; if(!p) //指针p指向了查找路径上访问的最后一个结点 T=s;//这里是判断若整个二叉树为空，则把s作为根节点 else if(LT(e.key,p-&gt;data.key) p-&gt;lchild=s; else p-&gt;rchild=s; return TRUE; &#125; else return FALSE;&#125;//InsertBST 二叉排序树的生成注意：若有重复元素，则不再插入。 二叉排序树的删除要删除二叉排序树中的p结点，分三种情况： (1) p为叶子结点，只需修改p双亲f的指针f-&gt;lchild=NULL f-&gt;rchild=NULL (2) p只有左子树或右子树p只有左子树，用p的左孩子代替p (1)(2)p只有右子树，用p的右孩子代替p (3)(4) (3) p左、右子树均非空沿p左子树的根C的右子树分支找到S，满足S的右子树为空，将S的左子树成为S的双亲Q的右子树，用S取代p (5)若C无右子树，用C取代p (6) 也即S替代要删的店，S的左子树替代S。 算法在二叉排序树中删除一个节点的算法12345678910111213141516171819202122232425262728Status DeleteBST(BiTree &amp;T,KeyType key)&#123; if(!T) return FALSE; else&#123; if EQ(key,T-&gt;data.key) Delete(T); else if LT(key,T-&gt;data.key) DeleteBST(T-&gt;lchild, key); else DeleteBST(T-&gt;rchild, key); return TRUE; &#125;&#125;void Delete(BiTree &amp;p)&#123; if(!p-&gt;rchild)&#123;q=p;p=p-&gt;lchild;free(q);&#125; //用p的左孩子代替p else if(!p-&gt;lchild)&#123;q=p;p=p-&gt;rchild;free(q);&#125; //用p的右孩子代替p else&#123; q=p;s=p-&gt;lchild; while(s-&gt;rchild)&#123;q=s;s=s-&gt;rchild;&#125; //转左，然后向右到尽头 p-&gt;data=s-&gt;data; //s指向被删结点的\"前驱\" if(q!=p) q-&gt;rchild=s-&gt;lchild; //重接*q的右子树 else q-&gt;lchild=s-&gt;lchild; //重接*q的左子树 &#125;&#125;//delete 二叉排序树性能分析只有二叉排序树为平衡树时，其平均查找时间为O(log n)，反之，可能退化直到顺序查找O(n)。 平衡二叉树定义平衡二叉树又称AVL树。它或者是一棵空树，或者是具有下列性质的二叉树：它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值不超过1。 平衡因子 结点的平衡因子BF(Balance Factor)是左子树的深度减去右子树的深度,它只可能是 -1, 0, 1 二叉排序树转成平衡树失去平衡后进行调整的四种情况 单向右旋平衡处理 LL型当在左子树上插入左结点,使平衡因子由1增至2时调整过程将BA向右旋转90度，把B的右孩子变为A的左孩子，A变为B的右孩子，B替代A的位置。 单向左旋平衡处理 RR型当在右子树上插入右结点,使平衡因子由-1增至-2时调整过程将BA向右旋转90度，把B的右孩子变为A的左孩子，A变为B的右孩子，B替代A的位置。 双向旋转(先左后右)平衡处理 LR型当在左子树上插入右结点,使平衡因子由1增至2时调整过程1）将CB向左旋转90度，把CL变为B的右子树，把B变为C 的左孩子；2）将BCA向右旋转90 度，把CR变为A的左孩子，A变为C的右孩子；最后，C带替A的位置。 双向旋转(先右后左)平衡处理 RL型当在右子树上插入左结点,使平衡因子由-1增至-2时调整过程1）将CB向右旋转90度，把CR变为B的右子树，把B变为C的左孩子；2）将BCA向左旋转90度，把C的左孩子变为A的右孩子，A变为C的左孩子；最后，C带替A的位置。 平衡二叉树的查找及性能分析它的时间复杂度与二叉排序树的最好时间复杂相同，都为O(log2n)。 B-树 类似“多叉的”二叉查找树 定义B-树中所有结点中孩子结点个数的最大值成为B-树的阶，通常用m表示，从查找效率考虑，一般要求m&gt;=3。一棵m阶B-树或者是一棵空树，或者是满足以下条件的m叉树。1）每个结点最多有m个分支（子树）；而最少分支数要看是否为根结点，如果是根结点且不是叶子结点，则至少要有两个分支，非根非叶结点至少有ceil(m/2)个分支，这里ceil代表向上取整。2）如果一个结点有n-1个关键字，那么该结点有n个分支。这n-1个关键字按照递增顺序排列。3）每个结点的结构为：n k1 k2 … knp0 p1 p2 … pn 其中，n为该结点中关键字的个数；ki为该结点的关键字且满足ki&lt;ki+1；pi为该结点的孩子结点指针且满足pi所指结点上的关键字大于ki且小于ki+1，p0所指结点上的关键字小于k1，pn所指结点上的关键字大于kn。 4）结点内各关键字互不相等且按从小到大排列。5）叶子结点处于同一层；可以用空指针表示，是查找失败到达的位置。 注：平衡m叉查找树是指每个关键字的左侧子树与右侧子树的高度差的绝对值不超过1的查找树，其结点结构与上面提到的B-树结点结构相同，由此可见，B-树是平衡m叉查找树，但限制更强，要求所有叶结点都在同一层。 摘录了大佬 文哥的学习日记 的实例，原文链接在开篇已经给出。 上面的图片显示了一棵B-树，最底层的叶子结点没有显示。我们对上面提到的5条特点进行逐条解释：1）结点的分支数等于关键字数+1，最大的分支数就是B-树的阶数，因此m阶的B-树中结点最多有m个分支，所以可以看到，上面的一棵树是一个5-阶B-树。2）因为上面是一棵5阶B-树，所以非根非叶结点至少要有ceil(5/2)=3个分支。根结点可以不满足这个条件，图中的根结点有两个分支。3）如果根结点中没有关键字就没有分支，此时B-树是空树，如果根结点有关键字，则其分支数比大于或等于2，因为分支数等于关键字数+1.4）上图中除根结点外，结点中的关键字个数至少为2，因为分支数至少为3，分支数比关键字数多1，还可以看出结点内关键字都是有序的，并且在同一层中，左边结点内所有关键字均小于右边结点内的关键字，例如，第二层上的两个结点，左边结点内的关键字为15，26，他们均小于右边结点内的关键字39和45.B-树一个很重要的特征是，下层结点内的关键字取值总是落在由上层结点关键字所划分的区间内，具体落在哪个区间内可以由指向它的指针看出。例如，第二层最左边的结点内的关键字划分了三个区间，小于15，15到26，大于26，可以看出其下层中最左边结点内的关键字都小于15，中间结点的关键字在15和26之间，右边结点的关键字大于26.5）上图中叶子结点都在第四层上，代表查找不成功的位置。 B-树上的查找（1）将给定key值与根结点关键字k[i]（k[]为结点内的关键字数组）比较，如果相等，那么查找成功。（2） 若key&lt;k[1]，则到p[0]所指示的子树中进行继续查找（p[ ]为结点内的指针数组)，这里要注意B-树中每个结点的内部结构。 若key&gt;k[n]，则道p[n]所指示的子树中继续查找。 若k[i]&lt;key&lt;k[i+1]，则沿着指针p[I]所指示的子树继续查找。 （3）如果，查找到叶子结点，那么查找失败。 B-树上的插入与二叉排序树一样，B-树的创建过程也是将关键字逐个插入到树中的过程。在进行插入之前，要确定一下每个结点中关键字个数的范围，如果B-树的阶数为m，则结点中关键字个数的范围为 [ceil(m/2)-1,m-1] 个。对于关键字的插入，需要找到插入位置。在B-树的查找过程中，当遇到空指针时，则证明查找不成功，同时也找到了插入位置，即根据空指针可以确定在最底层非叶结点中的插入位置，为了方便，我们称最底层的非叶结点为终端结点，由此可见，B-树结点的插入总是落在终端结点上。在插入过程中有可能破坏B-树的特征，如新关键字的插入使得结点中关键字的个数超过规定个数，这是要进行结点的拆分。 接下来，我们以关键字序列{1,2,6,7,11,4,8,13,10,5,17,9,16,20,3,12,14,18,19,15}创建一棵5阶B-树，我们将详细体会B-树的插入过程。（1）确定结点中关键字个数范围由于题目要求建立5阶B-树，因此关键字的个数范围为2～4（2）根结点最多可以容纳4个关键字，依次插入关键字1、2、6、7后的B-树如下图所示：（3）当插入关键字11的时候，发现此时结点中关键字的个数变为5，超出范围，需要拆分，去关键字数组中的中间位置，也就是k[3]=6，作为一个独立的结点，即新的根结点，将关键字6左、右关键字分别做成两个结点，作为新根结点的两个分支，此时树如下图所示：（4）新关键字总是插在叶子结点上，插入关键字4、8、13之后树为： （5）关键字10需要插入在关键字8和11之间，此时又会出现关键字个数超出范围的情况，因此需要拆分。拆分时需要将关键字10纳入根结点中，并将10左右的关键字做成两个新的结点连在根结点上。插入关键字10并经过拆分操作后的B-树如下图： （6）插入关键字5、17、9、16之后的B-树如图所示： （7）关键字20插入在关键字17以后，此时会造成结点关键字个数超出范围，需要拆分，方法同上，树为： （8）按照上述步骤依次插入关键字3、12、14、18、19之后B-树如下图所示： （9）插入最后一个关键字15，15应该插入在14之后，此时会出现关键字个数超出范围的情况，则需要进行拆分，将13并入根结点，13并入根结点之后，又使得根结点的关键字个数超出范围，需要再次进行拆分，将10作为新的根结点，并将10左、右关键字做成两个新结点连接到新根结点的指针上，这种插入一个关键字之后出现多次拆分的情况称为连锁反应，最终形成的B-树如下图所示： B-树的删除对于B-树关键字的删除，需要找到待删除的关键字，在结点中删除关键字的过程也有可能破坏B-树的特性，如旧关键字的删除可能使得结点中关键字的个数少于规定个数，这是可能需要向其兄弟结点借关键字或者和其孩子结点进行关键字的交换，也可能需要进行结点的合并，其中，和当前结点的孩子进行关键字交换的操作可以保证删除操作总是发生在终端结点上。 我们用刚刚生成的B-树作为例子，一次删除8、16、15、4这4个关键字。（1）删除关键字8、16。关键字8在终端结点上，并且删除后其所在结点中关键字的个数不会少于2，因此可以直接删除。关键字16不在终端结点上，但是可以用17来覆盖16，然后将原来的17删除掉，这就是上面提到的和孩子结点进行关键字交换的操作。这里不能用15和16进行关键字交换，因为这样会导致15所在结点中关键字的个数小于2。因此，删除8和16之后B-树如下图所示： （2）删除关键字15，15虽然也在终端结点上，但是不能直接删除，因为删除后当前结点中关键字的个数小于2。这是需要向其兄弟结点借关键字，显然应该向其右兄弟来借关键字，因为左兄弟的关键字个数已经是下限2.借关键字不能直接将18移到15所在的结点上，因为这样会使得15所在的结点上出现比17大的关键字，所以正确的借法应该是先用17覆盖15，在用18覆盖原来的17，最后删除原来的18，删除关键字15后的B-树如下图所示： （3）删除关键字4，4在终端结点上，但是此时4所在的结点的关键字个数已经到下限，需要借关键字，不过可以看到其左右兄弟结点已经没有多余的关键字可借。所以就需要进行关键字的合并。可以先将关键字4删除，然后将关键字5、6、7、9进行合并作为一个结点链接在关键字3右边的指针上，也可以将关键字1、2、3、5合并作为一个结点链接在关键字6左边的指针上，如下图所示： 显然上述两种情况下都不满足B-树的规定，即出现了非根的双分支结点，需要继续进行合并，合并后的B-树如下图所示：有时候删除的结点不在终端结点上，我们首先需要将其转化到终端结点上，然后再按上面的各种情况进行删除。在讲述这种情况下的删除方法之前，要引入一个相邻关键字的概念，对于不在终端结点的关键字a，它的相邻关键字为其左子树中值最大的关键字或者其右子树中值最小的关键字。找a的相邻关键字的方法为：沿着a的左指针来到其子树根结点，然后沿着根结点中最右端的关键字的右指针往下走，用同样的方法一直走到叶结点上，叶结点上的最右端的关键字即为a的相邻关键字（这里找的是a左边的相邻关键字，我们可以用同样的思路找到a右边的相邻关键字）。可以看到下图中a的相邻关键字是d和e，要删除关键字a，可以用d来取代a，然后按照上面的情况删除叶子结点上的d即可。 B-树的应用为了将大型数据库文件存储在硬盘上，以减少访问硬盘次数为目的，在此提出了一种平衡多路查找树——B-树结构。由其性能分析可知它的检索效率是相当高的 为了提高 B-树性能’还有很多种B-树的变型，力图对B-树进行改进，比如B+树。 B+树B+树是应文件系统所需而出的一种B-树的变型树。一棵m阶的B+树和m阶的B-树的差异在于： 有n棵子树的结点中含有n个关键字。 所有的叶子结点中包含了全部关键字信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。 所有的非终端结点可以看成是索引部分，结点中仅含有其子树（根结点）中的最大（或最小）关键字。键树又称数字查找树，它是一棵度≥2的树，树中的每个结点中不是包含一个或几个关键字，而是只含有组成关键字的符号。 例如，若关键字为数值，则结点中只包含一个数位；若关键字为单词，则结点中只包含一个字母字符。这种树会给某种类型关键字的表的查找带来方便。 哈希查找基本思想在记录的存储地址和它的关键字之间建立一个确定的对应关系；这样，不经过比较，一次存取就能得到所查元素的查找方法 定义哈希函数在记录的关键字与记录的存储地址之间建立的一种对应关系叫哈希函数。addr(ai)=H(ki)其中，ai是表中元素，addr()是取址函数，ki是ai的关键字，H()是哈希函数。 关键字集合——H( )——&gt;存储地址集合 哈希表应用哈希函数，由记录的关键字确定记录在表中的地址，并将记录放入此地址，这样构成的表叫哈希表。 哈希查找又叫散列查找，利用哈希函数进行查找的过程。 哈希函数的构造方法直接定址法 构造取关键字或关键字的某个线性函数作哈希地址，即H(key)=key 或 H(key)=a·key+b 特点直接定址法所得地址集合与关键字集合大小相等，不会发生冲突 实际中能用这种哈希函数的情况很少 数字分析法 构造对关键字进行分析，取关键字的若干位或其组合作哈希地址 适于关键字位数比哈希地址位数大，且可能出现的关键字事先知道的情况 平方取中法 构造取关键字平方后中间几位作哈希地址 适于不知道全部关键字情况 折叠法 构造将关键字分割成位数相同的几部分，然后取这几部分的叠加和（舍去进位）做哈希地址 种类移位叠加：将分割后的几部分低位对齐相加间界叠加：从一端沿分割界来回折送，然后对齐相加 适于关键字位数很多，且每一位上数字分布大致均匀情况除留余数法 构造取关键字被某个不大于哈希表表长m的数p除后所得余数作哈希地址，即H(key)=key MOD p，pm 特点简单、常用，可与上述几种方法结合使用p的选取很重要；p选的不好，容易产生同义词 随机数法 构造取关键字的随机函数值作哈希地址，即H(key)=random(key) 适于关键字长度不等的情况选取哈希函数的因素 计算哈希函数所需时间 关键字长度 哈希表长度（哈希地址范围） 关键字分布情况 记录的查找频率处理冲突的方法开放定址法 方法当冲突发生时，形成一个探查序列；沿此序列逐个地址探查，直到找到一个空位置（开放的地址），将发生冲突的记录放到该地址中， 即hash(key) = （hash(key)+di）mod TableSize。di为增量序列，TableSize为表长。 分类线性探测再散列：di=1,2,3,……m-1二次探测再散列：di=1²,-1²,2²,-2²,3²,……±k²(k &lt;= m/2)伪随机探测再散列：di=伪随机数序列 再哈希法 方法构造若干个哈希函数，当发生冲突时，计算下一个哈希地址，即：Hi=Rhi(key) i=1,2,……k其中：Rhi——不同的哈希函数 特点计算时间增加链地址法 方法将所有关键字为同义词的记录存储在一个单链表中，并用一维数组存放头指针。 哈希查找过程及分析哈希查找过程 哈希查找分析 哈希查找过程仍是一个给定值与关键字进行比较的过程 评价哈希查找效率仍要用ASL 哈希查找过程与给定值进行比较的关键字的个数取决于： 哈希函数 处理冲突的方法 哈希表的填满因子=表中填入的记录数/哈希表长度 哈希表小结 散列方法的查找效率不依赖于n ，只依赖于负载因子 α=n/M n为散列表中关键字个数,M为散列表表长,散列表检索的平均检索长度只随α 的增大而增加。 散列方法的应用限制散列方法一般不适用于重复关键码值的应用程序散列方法一般不适用于范围检索","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://daybreakland.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构 | 栈和队列","slug":"3.0栈和队列","date":"2019-12-06T14:34:58.000Z","updated":"2019-12-09T01:44:04.983Z","comments":true,"path":"2019/12/06/3.0栈和队列/","link":"","permalink":"https://daybreakland.top/2019/12/06/3.0%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/","excerpt":"顺序栈、链栈、循环队列、链队列","text":"顺序栈、链栈、循环队列、链队列 学习目标掌握栈和队列这两种抽象数据类型的特点，并能在相应的应用问题中正确选用它们。熟练掌握栈类型的两种实现方法。熟练掌握循环队列和链队列的基本操作实现算法。理解递归算法执行过程中栈的状态变化过程。 知识点顺序栈、链栈、循环队列、链队列 栈只允许在一端插入和删除的顺序表允许插入和删除的一端称为栈顶 (top) —表尾另一端称为栈底(bottom) —表头不含元素的空表称空栈特点: 先进后出（FILO）或后进先出（LIFO） ADT1234567891011121314151617181920212223242526272829303132333435363738ADT Stack&#123;数据对象：D=&#123;ai|ai∈ElemSet,i=1,2,…,n,n≥0&#125;数据关系：R=&#123;&lt;ai-1,ai&gt;|ai,ai-1∈D,i=2,…,n&#125; 约定:an为栈顶，a1为栈底基本操作： InitStack(&amp;S) 操作结果:构造一个空的栈S。 DestroyStack(&amp;S) 初始条件: 栈S已经存在。 操作结果: 销毁栈S。 ClearStack(&amp;S) 初始条件: 栈S已经存在。 操作结果: 将栈S重置为空栈。 StackEmpty(S) 初始条件: 栈S已经存在。 操作结果: 若栈S为空栈，则返回TURE;否则返回FALSE -判定栈是否为空栈是栈在应用程序中经常使用的操作，通常以它作为循环结束的条件。 StackLength(S) 初始条件: 栈S已经存在。 操作结果: 返回栈S中的数据元素个数。 GetTop(S,&amp;e) 初始条件: 栈S已经存在且非空。 操作结果: 用e返回栈S中栈顶元素的值。 -这是取栈顶元素的操作，只以 e 返回栈顶元素，并不将它从栈中删除。 Push(&amp;S,e) 初始条件: 栈S已经存在。 操作结果: 插入元素e为新的栈顶元素。 -这是入栈操作，在当前的栈顶元素之后插入新的栈顶元素。 Pop(&amp;S,&amp;e) 初始条件: 栈S已经存在且非空。 操作结果: 删除S的栈顶元素并用e返回其值。 -这是出栈操作，不仅以 e 返回栈顶元素，并将它从栈中删除。 StackTraverse(S,visit ()) 初始条件: 栈S已经存在且非空。 操作结果: 从栈底到栈顶依次对S的每个元素调用函数visit ()。一旦visit ()失败，则操作失败。 -这是对栈进行从栈底到栈顶的\"遍历\"操作，应用较多的场合是，输出栈中所有数据元素。&#125; 栈的表示和实现两种 顺序存储结构__顺序栈； 链式存储结构__链栈；顺序栈的定义利用一组地址连续的存储单元依次自栈底到栈顶存放栈的数据元素。 栈顶指针top指向实际栈顶后的空位置，初值为0 top=0,栈空， 此时出栈，则下溢（underflow)top=M,栈满，此时入栈，则上溢（overflow) 顺序栈的数据类型123456789#define STACK_INIT_SIZE 100；//存储空间初始分配量#define STACKINCREMENT 10；//存储空间分配增量typedef struct&#123; SElemType *base; //在栈构造之前和销毁之后,值为null SElemType *top; //栈顶指针 int StackSize; //当前已分配的存储空间，以元素为单位&#125; SqStack; 顺序栈的操作InitStack1234567891011Status InitStack( SqStack &amp;S )&#123; S.Base=(SElemType *)malloc(STACK_INIT_SIZE*sizeof(SElemType)); if(!S.Base) &#123; return OVERFLOW; &#125; S.Top = S.Base; S.StackSize = STACK_INIT_SIZE; return OK;&#125;// InitStack GetTop12345678910111213// 用e返回栈S的栈顶元素，若栈空，函数返回ERRORStatus GetTop( SqStack S, SElemType &amp;e) &#123; if( S.Top != S.Base ) // 栈空吗？ &#123; e = *( S.Top – 1 ); return OK; &#125; else &#123; return ERROR; &#125;&#125;// GetTop Push12345678910111213141516//把元素e入栈Status Push(SqStack &amp;S, SElemType e )&#123; // 若栈满，追加存储空间 if( S.Top &gt;= S.Base + S.StackSize ) &#123; S.Base= (SElemType *)realloc(S.Base,(S.StackSize + STACKINCREMENT) *sizeof(SElemType)); if( !S.Base ) return OVERFLOW; //存储分配失败 S.Top = S.Base + S.StackSize; S.StackSize += STACKINCREMENT; &#125; *S.Top = e; S.Top++; return OK;&#125;// Push Pop1234567891011// 出栈Status Pop( SqStack &amp;S, SElemType &amp;e )&#123; if( S.Top == S.Base ) // 空吗？ &#123; return ERROR; &#125; S.Top --; e = *S.Top; return OK;&#125;// Pop 链栈定义12345678typedef struct&#123; SLink top; // 栈顶指针 int length; // 栈中元素个数 &#125;Stack; typedef struct node&#123; int data; struct node *next;&#125;*SLink; 栈的应用举例把10进制数159转换成8进制数因此，需要先保存在计算过程中得到的八进制数的各位，然后逆序输出，因为它是按”后进先出”的规律进行的，所以用栈最合适。 12345678910111213void conversion () &#123;// 对于输入的任意一个非负十进制整数，打印输出与其等值的八进制数 InitStack(S); // 构造空栈 scanf (\"%d\",N); while (N) &#123; Push(S, N % 8); N = N/8; &#125; while (!StackEmpty(S)) &#123; Pop(S,e); printf ( \"%d\", e ); &#125;&#125; // conversion 括弧匹配检验现在的问题是，要求检验一个给定表达式中的括弧是否正确匹配？ 检验括号是否匹配的方法可用“期待的急迫程度”这个概念来描述。 12345678910111213141516171819status matching(string&amp; exp) &#123;// 检验表达式中所含括弧是否正确嵌套，若是，则返回// OK，否则返回ERROR int state = 1; while (i&lt;=length(exp) &amp;&amp; state) &#123; swith of exp[i] &#123; case \"(\": &#123;Push(S,exp[i]); i++; break;&#125; case \")\": &#123; if (NOT StackEmpty(S) &amp;&amp; GetTop(S) = \"(\") &#123; Pop(S,e); i++; &#125; else&#123; state = 0 &#125; break; &#125; … &#125; &#125; if ( state &amp;&amp; StackEmpty(S) ) return OK else return ERROR;&#125; 行编辑程序问题 一个简单的行编辑程序的功能是：接受用户从终端输入的程序或数据，并存入用户的数据区。每接受一个字符即存入用户数据区。 较好的做法是，设立一个输入缓冲区，用以接受用户输入的一行字符，然后逐行存入用户数据区。允许用户输入出差错，并在发现有误时可以及时更正。例如，可用一个退格符“#”表示前一个字符无效；可用一个退行符“@”，表示当前行中的字符均无效。例如，假设从终端接受了这样两行字符： whli##ilr#e（s#*s) outcha@putchar(*s=#++); 则实际有效的是下列两行： while (s) putchar(s++); 1234567891011121314151617181920void LineEdit() &#123;// 利用字符栈S，从终端接收一行并传送至调用过程// 的数据区。 InitStack(S); //构造空栈S ch = getchar(); //从终端接收第一个字符 while (ch != EOF) &#123; //EOF为全文结束符 while (ch != EOF &amp;&amp; ch != '\\n') &#123; switch (ch) &#123; case '#' : Pop(S, c); break; // 仅当栈非空时退栈 case '@': ClearStack(S); break; // 重置S为空栈 default : Push(S, ch); break; // 有效字符进栈,未考虑栈满情形 &#125; ch = getchar(); // 从终端接收下一个字符 &#125; 将从栈底到栈顶的字符传送至调用过程的数据区 ClearStack(S); // 重置S为空栈 if (ch != EOF) ch = getchar(); &#125; DestroyStack(S);&#125; 表达式求值 规则：先乘除，后加减；从左到右；先括号内，后括号外； 把运算符和界限符统称为算符 “算符优先法”4 - 10 / 5 + 2 * ( 3 + 8 ) 44 -4 - 104 - 10 /4 - 10 / 54 - 10 / 5 + =&gt; 4 – 2 +4 - 2 + =&gt; 2 +2 + 22 + 2 *2 + 2 * (2 + 2 * ( 32 + 2 * ( 3 +2 + 2 * ( 3 + 82 + 2 * ( 3 + 8 ) =&gt; 2 + 2 * 11 =&gt; 2 + 22 =&gt; 26 算符优先法根据这个运算优先关系的规定来实现对表达式的编译或解释执行。算符间的优先关系算法描述 12345678910111213141516171819202122232425262728293031323334//表达式求值OpendType EvaluateExpression( )&#123; InitStack( OPTR ); Push( OPTR, ‘#’ ); InitStack( OPND ); c = getchar( ); while(!(c == ‘#’ &amp;&amp; GetTop( OPTR ) == ‘#’) )&#123; if(!In(c,OP)) // c是运算符？,OP是运算符集合 &#123; Push( OPND, c); c = getchar( ); &#125; else &#123; switch( Precede ( GetTop( OPTR), c )) &#123; case ‘&lt;’ : //栈顶元素优先权低 Push( OPTR, c ); c = getchar( ); break; case ‘=‘ : // c为’)’ Pop( OPTR, x ); c = getchar( ); break; case ‘&gt;’: //退栈并将运算结果入栈 Pop( OPTR, t ); Pop( OPND, b ); Pop( OPND, a ); Push( OPND, Operate( a, t, b )); break; &#125;// switch &#125;// while return GetTop( OPND );&#125;// EvaluateExpression 过程的嵌套调用…… 汉诺塔问题…… 队列定义一种先进先出的线形表。只允许在表一端插入，在另一端删除。 概念队尾rear：插入端，线性表的表尾。队头front：删除端，线性表的表头。FIFO（First In First Out）ADT 12345678910111213141516ADT Queue&#123;数据对象：D=&#123;ai|ai∈ElemSet,i=1,2,…,n,n≥0&#125;数据关系：R=&#123;&lt;ai-1,ai&gt;|ai,ai-1∈D,i=2,…,n&#125; 约定:a1为队列头，an为队列尾基本操作： InitQueue( &amp;Q ); // 初始化空队列 DestroyQueue( &amp;Q ); // 销毁队列 ClearQueue( &amp;Q ); // 清空队列 QueueEmpty( Q ); // 队列空？ QueueLength( Q ); // 队列长度 GetHead( Q, &amp;e ); // 取对头元素 EnQueue( &amp;Q, e ); // 入队列 DeQueue( &amp;Q, &amp;e ); // 出队列 QueueTraverse( Q, visit( )); // 遍历&#125;//ADT Queue; 双端队列简介可以从两端进行插入或者删除操作的队列。 队列的表示和实现两种 链式存储结构__链队列； 顺序存储结构__循环队列；链队列类型说明12345678typedef struct Qnode &#123; QElemType data; struct QNode *next;&#125;QNode,*QueuePtr; // 结点typedef struct&#123; QueuePtr fornt; // 队头指针 QueuePtr rear; // 队尾指针&#125;LinkQueue; 结点定义 1234typedef struct Qnode&#123; QElemType data; struct QNode *Next;&#125;QNode 链队列的基本操作初始化12345678910// 初始化一个空队列Status InitQueue( LinkQueue &amp;Q )&#123; Q.Front=Q.Rear=(QueuePtr)malloc(sizeof(QNode)); if(!Q.front) &#123; return OVERFLOW; &#125; Q.front-&gt;Next=NULL;&#125;//InitQueue 销毁123456789// 销毁队列Status DestroyQueue(LinkQueue &amp;Q)&#123; while(Q.Front)&#123; QRear = Q.Front -&gt;next; free( Q.Front ); Q.Front= QRear &#125; return OK; &#125;// DestroyQueue 入队12345678910// 入队列Stauts EnQueue( LinkQueue &amp;Q, QEmemType e )&#123; p=(QueuePtr)malloc(sizeof(QNode)); if( !p)&#123;return OVERFLOW; &#125;//存储分配失败 p-&gt;data = e; p-&gt;next = null ; Q.Rear-&gt;next = p; Q.Rear=p; return OK;&#125; 出队12345678910111213// 出队列 3-3-12-1.swfStatus DeQueue( LinkQueue &amp;Q, QElemType &amp;e )&#123; if(Q.Front==Q.rear) return ERROR; p = Q.Front-&gt;Next ;//p指向队头 e = p-&gt;data;//取队头元素值（可以直接用e完成对队头取值） Q.Front-&gt;next = p-&gt;next;//头结点指向原队头的下一个节点 if(Q.rear==p) //尾头同指向，队列就空了，释放队列 Q.rear=Q.front; free( p ); return OK;&#125;// Dequeue 循环队列》 基本思想：把队列设想成环形，让sq[0]接在sq[M-1]之后，若rear+1==M,则令rear=0;》实现：利用“模”运算》入队： rear=(rear+1)%M; sq[rear]=x;》出队： front=(front+1)%M; x=sq[front];》队满、队空判定条件 会存在判断队空和队满时，条件均为front==rear的情况 解决方案：少用一个元素空间队空：front= =rear队满：(rear+1)%M= =front约定以“队列头指针在队列尾指针的下一位置上”作为队列呈“满”状态的标志,在同一位置则是空。循环队列的基本操作基本模块说明 1234567#define MAXQSIZE 100 //队列最大长度typedef struct&#123; QElemType *Base; // pBase指向数组名（通常静态队列都使用循环队列） int Front; // 头指针，数组下标，此处规定从零开始 int Rear; // 尾指针&#125;SqQueue; 初始化1234567Status InitQueue( SqQueue &amp;Q )&#123; Q.Base = (QElemTYpe *)malloc( MAXQSIZE * sizeof( QElemType )); if( !Q.Base )&#123; return OVERFLOW;&#125; Q.Front = Q.Rear = 0; return OK;&#125;// InitQueue 队列长度1234int QueueLength( SqQueue Q )&#123; return Q.Rear – Q.Front + MAXQSIZE) % MAXQSIZE;&#125; 3 入队列123456Status EnQueue( SqQueue &amp;Q, QElemType e )&#123; if( (Q.Rear + 1)%MAXQSIZE == Q.Front )&#123; return ERROR;&#125; // 队列满？ Q.Base[Q.Rear] = e; Q.Rear = ( Q.Rear + 1 ) % MAXQSIZE;&#125;// EnQueue 出队列1234567Status DeQueue( SqQueue &amp;Q, QElemType &amp;e )&#123; if( Q.Front == Q.Rear )&#123; return ERROR;&#125; // 对列空？ e = Q.Base[Q.Front]; Q.Front = (Q.Front + 1) % MAXQSIZE; return OK;&#125;// DeQueue; 队列应用举例由事件驱动的程序银行业务模拟系统 顾客到达银行选择一个人数最少的柜台排队，如果该柜台没有人，则直接开始办理业务，并准备该顾客的业务完成事件。如果未到下班时间，则准备下一个顾客到达银行的事件。 顾客业务完成顾客完成业务离开，下一个顾客开始办理业务，并准备该队列中下一个顾客的业务完成事件。 初始化事件队列；起始事件（第一个顾客到达事件）入队；循环，直至事件队列空 事件出队； 若为到达事件，则 选择人数最少的柜台排队； 若该柜台无人排队，则业务完成事件入队； 若未到下班时间，则下一个顾客到达事件入队； 若为业务完成事件，则 顾客离开； 若该柜台还有人排队，则准备下一个人的业务完成事件；","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://daybreakland.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构 | 线性表","slug":"2.0线性表","date":"2019-12-03T09:40:48.000Z","updated":"2019-12-09T01:43:56.794Z","comments":true,"path":"2019/12/03/2.0线性表/","link":"","permalink":"https://daybreakland.top/2019/12/03/2.0%E7%BA%BF%E6%80%A7%E8%A1%A8/","excerpt":"线性表的顺序和链式结构线性链表、循环链表、双向链表","text":"线性表的顺序和链式结构线性链表、循环链表、双向链表 主要内容线性结构特点在非空有限集内，存在唯一始末元素、除头全有唯一前驱，除尾全有唯一后继。 2.1 线性表的类型定义 2.2 线性表的顺序表示与实现 2.3 线性表的链式表示与实现 2.3.1 线性链表 2.3.2 循环链表 2.3.3 双向链表 线性表的逻辑结构定义一个线性表是n个数据元素的有限序列 特点1.线性表中所有元素的性质相同。 2.除第一个和最后一个数据元素之外，其它数据元素有且仅有一个前驱和一个后继。第一个数据元素无前驱，最后一个数据元素无后继。 3.数据元素在表中的位置只取决于它自身的序号。 ADT1234567891011121314151617ADT List&#123; 数据对象：D=&#123;ai|ai∈ElemSet,i=1,2,…,n,n≥0&#125; 数据关系：R=&#123;&lt;ai-1,ai&gt;|ai,ai-1∈D,1=2,…,n&#125; 基本操作： InitList( &amp;L); DestroyList(&amp;L); ClearList(&amp;L); ListEmpty(L); ListLength(L); GetElement(L,i,&amp;e); LocateElement(L,e,compare( )) PriorElement(L,cur_e,&amp;pre_e) NextElement(L,cur_e,&amp;next_e) ListInsert(&amp;L,i,e); ListDelete(&amp;L,i,&amp;e); ListTraverse(L,visit( ))&#125;ADT List 例题线性表合并假设有两个集合A和B分别用两个线性表LA和LB表示,现要求一个新的集合A＝A∪B。 12345678910111213void union( List &amp;La, List Lb)&#123; // 将所有在线性表Lb中但不在La中的数据元素插入到La中 La_Len = ListLength( La ); // 求线性表的长度 Lb_Len = ListLength( Lb ); for( i = 1; i &lt;= Lb_Len; i++) &#123; GetElem( Lb, i, e); // 取Lb中第i个数据元素赋给e if( !LocateElem( La, e, equal)) ListInsert( La, ++La_Len, e); // La中不存在和 e 相同的数据元素，则插入之 &#125;&#125; // union 时间复杂度： O(ListLength( La ) * ListLength( Lb )) 非递减线性表La,Lb的合并123456789101112131415161718192021222324252627void MergeList( List La, List Lb, List &amp;Lc )&#123; InitList( Lc ); i = j = 1; // i和j分别是La和Lb的序号 k = 0; //k是Lc的序号 La_Len = ListLength( La ); Lb_Len = ListLength( Lb ); while((i &lt;= La_Len) &amp;&amp; (j &lt;= Lb_Len)) &#123; GetElem( La, i, ai ); GetElem( Lb, j, bj ); if( ai &lt; = bj ) &#123; ListInsert( Lc, ++k, ai); ++i; &#125; else &#123; ListInsert( Lc, ++k, bj ); ++j; &#125; &#125; while( i &lt;= La_Len )&#123;//若La非空，把La剩余的数据元素插入到Lc中 GetElem( La, i++, ai ); ListInsert( Lc, ++k, ai ); &#125; while( j &lt;= Lb_Len )&#123;//若Lb非空，把La剩余的数据元素插入到Lc中 GetElem( Lb, j++, bj ); ListInsert( Lc, ++k, bj ); &#125;&#125;//MergeList 时间复杂度： O(ListLength(La ) + ListLength( Lb)) 线性表的顺序存储结构顺序表：用一组地址连续的存储单元存放一个线性表 元素地址计算方法：LOC(ai)=LOC(a1)+(i-1)*LL—一个元素占用的存储单元个数LOC(ai)—线性表第i个元素的地址 特点： 实现逻辑上相邻—物理地址相邻 实现随机存取 顺序表的类型定义1234567#define LIST_INIT_SIZE 100 // 线性表存储空间的初始分配量 #define LISTINCREMENT 10 // 线性表存储空间的分配增量typedef struct&#123; ElemType *elem；//存储空间基址 int length； //当前长度 int listsize //当前分配的存储容量（以sizeof（ElemType）为单位）&#125;Sqlist； 顺序表的重要操作初始化顺序表123456789Status InitList_Sq(SqList &amp;L)&#123; //构造一个空的顺序表L L.elem=(ElemType*)malloc(LIST_INIT_SIZE*sizeof(ElemType)); if (! L.elem) exit(OVERFLOW); //存储分配失败 L.length=0; //空表长度为0 L.listsize=LIST_INIT_SIZE; //初始存储容量 Return OK;&#125;//InitList_Sq 顺序表的插入操作思路1.输入是否有效？2.当前表是否已经满？3.移动 i 后的元素4.插入元素5.表长增1 代码12345678910111213141516171819Status ListInsert_Sq(Sqlist &amp;L, int i, ElemType e) &#123; // 在顺序线性表L的第i个位置之前插入新的元素e // i的合法值为1&lt;=i&lt;=ListLength_Sq(L) + 1 if(i&lt;1 || i&gt;L.length+1) return ERROR; //i值不合法 if(L.length&gt;=L.listsize)&#123; // 当前存储空间已满,增加分配 newbase=(ElemType*)realloc(L.elem,(L.listsize+LISTINCREMENT)*sizeof(ElemType)); if(!newbase) exit(OVERFLOW); // 存储分配失败 L.elem=newbase; L.listsize+=LISTINCREMENT; // 增加存储容量 &#125; q=&amp;(L.elem[i-1]); // q为插入位置 for(p=&amp;(L.elem[L.length-1]); p&gt;=q; --p) *(p+1)=*p; // 插入位置及之后的元素后移 *q=e; // 插入e ++L.length; // 表长增1 return OK;&#125; 顺序表的删除操作思路1.输入是否有效？2.删除（前移元素）3.表长减1 代码12345678910111213Status ListDelete_Sq(SqList &amp;L,int i,ElemType &amp;e)&#123;//在顺序线性表L中删除第.i个元素，并用e返回其值 //i的合法值为 1≤i≤L.length if((i&lt;1)||(i&gt;L.Length)) return ERROR; // i值不合法或表空 p=&amp;(L.elem[i-1]); //p为被删除元素的位置 e=*p; // 被删除元素的值赋给e q=L.elem+L.length-1; // 表尾元素的位置 for (++p; p&lt;=q;++p) *(p-1)=*p; //被删除元素之后的元素前移 --L.length; //表长减1 return OK; &#125;//ListDelete_Sq 顺序表的查找操作1234567891011int LocateElem(SqList L,ElemType e, Status(*compare)(ElemType,ElemType))&#123; ElemType *p; int i=1; // i的初值为第1个元素的位序 p=L.elem; // p的初值为第1个元素的存储位置 while(i&lt;=L.length&amp;&amp;!compare(*p++,e)) ++i; if(i&lt;=L.length) return i; else return 0; &#125; 顺序表的遍历（函数指针使用说明书） 初始条件：顺序线性表L已存在 操作结果：依次对L的每个数据元素调用函数vi()。一旦vi()失败，则操作失败。若在vi()的形参加’&amp;’，表明可通过调用vi()改变元素的值。 12345678Status ListTraverse(SqList ,void(*vi)(ElemType&amp;))&#123; ElemType *p; int i; p=L.elem; for(i=1;i&lt;=L.length;i++) vi(*p++); return OK;&#125; 顺序表的一般操作销毁顺序表123456789Status DestroyList_Sq ( SqList &amp;L) &#123; if (!L.elem) return ERROR; // 若表L不存在 free (L.elem); // 若表L已存在，回收动态分配的存储空间 L.elem = null; L.length = 0; L.Listsize = 0; return OK; &#125;// DetroyList_Sq 置空线性表1234567 Status ClearList_Sq ( SqList &amp;L) &#123; if (!L.elem) return ERROR; // 若表L不存在 L.length = 0; //若表L已存在，将L置空 return OK; &#125;// ClearList_Sq 判断空表12345678Status ListEmpty(SqList L) &#123; // 初始条件：顺序线性表L已存在。 //操作结果：若L为空表，则返回TRUE，否则返回FALSE if(L.length==0) return TRUE; else return FALSE; &#125; 求表长12345int ListLength(SqList L)&#123; //初始条件：顺序线性表L已存在。 //操作结果：返回L中数据元素个数 return L.length;&#125; 取元素操作123456Status GetElem_Sq ( SqList L, int i, ElemType &amp;e ) &#123; if((i&lt; 1)||(i&gt;L.length)) return ERROR; // i 非法 e=L.elem[i-1]; //将顺序表中第i 个元素赋值给 e return OK; &#125;// GetElem_Sq 顺序存储结构的优缺点优点 逻辑相邻，物理相邻 可随机存取任一元素 存储空间使用紧凑缺点 插入、删除操作需要移动大量的元素 预先分配空间需按最大空间分配，利用不充分 表容量难以扩充线性表的链式存储结构特点 用一组任意的存储单元存储线性表的数据元素 利用指针实现了用不相邻的存储单元存放逻辑上相邻的元素 每个数据元素ai，除存储本身信息外，还需存储其直接后继的信息 结点{数据域：元素本身信息 指针域：指示直接后继的存储位置}线性链表的定义结点中只含一个指针域的链表叫线性链表，也叫单链表。 1234typedef struct LNode &#123; ElemType data; struct LNode *next;&#125;Lnode,*LinkList; LNode* p 和 LinkList p意思一样，都是建立一个Lnode型的单链表定义出来的都是1个Lnode型的指针变量，通常用他指向头结点特别地，注意LinkList P,Q; /P,Q都是指针 /LNode P,Q;/*只有P是指针 / 头结点在单链表第一个结点前附设一个结点叫头结点头结点指针域为空表示线性表为空链表的重要操作初始化链表1234567Status InitList_L (LinkList &amp;L) &#123; L = (LinkList)malloc(sizeof(LNode)); if (!L) exit(OVERFLOW); L-&gt;next = null; Return OK; &#125;// InitList_L 链表的按值查找123456789Status LocateNode_L(LinkList L，Elemtype key，LNode &amp;e)&#123; p=L–&gt;next; while( p &amp;&amp; p–&gt;data!=key) p=p–&gt;next; if(!p) return ERROR; e=p; return OK;&#125; 链表的插入操作思路 1.寻找第i-1个结点:顺指针向后查找，直到p指向第i-1个元素或p-&gt;next为空2.分配新空间3.插入节点 代码123456789101112131415Status ListInsert_L(LinkList &amp;L, int i, ElemType e)&#123; //在带头结点的线性链表L中第i元素结点之前插入元素e p=L; j=0 while (p&amp;&amp;j&lt;i-1)&#123; p=p-&gt;next; ++j; &#125;//☆寻找第i-1个元素结点 if(!p||j&gt;i-1) return ERROR; // i小于1 则 j&gt;i-1 // i大于表长+1 则p为空 s=(LinkList)malloc(sizeof(LNode)); //分配新结点 s-&gt;data=e; s-&gt;next=p-&gt;next; p-&gt;next=s; //插入新结点 return OK;&#125;//LinstInsert_L 链表的删除操作思路1.寻找第i-1个结点:顺指针向后查找，直到p指向第i-1个元素或p-&gt;next为空2.删除结点(修改其后继指针)3.回收（释放）结点空间 代码1234567891011121314Status ListDelete_L(LinkList &amp;L, int i, ElemType &amp;e)&#123; //在带头结点的单链线性表L中，删除第i个元素，并由e返回其值 p=L; j=0; while (p-&gt;next&amp;&amp;j&lt;i-1)&#123; //寻找第i-1个结点 p=p-&gt;next; ++j; &#125; if(!(p-&gt;next)||j&gt;i-1) return ERROR; // 表中无第i个结点(i不合法) // i&lt;1 则 j&gt;i-1 // i&gt;表长 则 p-&gt;next为空 q=p-&gt;next;p-&gt;next=q-&gt;next; //删除结点 e =q-&gt;data; free(q); // 释放结点空间 return OK;&#125;//LinstDelete_L 链表的一般操作取元素操作123456789101112Status GetElem_L(LinkList L, int i, ElemType &amp;e)&#123; //L为带头结点的单链表的头指针。 //当第i个元素存在时，其值赋给e并返回OK，否则返回ERROR p=L-&gt;next; j=1; //初始化，p指向第一个结点，j为计数器 while(p&amp;&amp; j&lt;i)&#123; //顺指针向后查找，直到p指向第i个元素或p为空 p=p-&gt;next;++j; &#125; if (!p||j&gt;i) return ERROR; //第i个元素不存在 e=p-&gt;data; //取第i个元素 return OK;&#125;//GetElem_L 头插法建立单链表思路① 建立新节点② 向新节点中添入内容③ 使新节点指向链头(第一个元素)④ 改变头指针,指向新节点 代码12345678910void CreateList_L(LinkList &amp;L, int n) &#123; //逆序输入n个元素的值，建立带表头结点的线性链表 L=（LinkList）malloc(sizeof (LNode)); L-&gt;next=NULL; //先建立一个带头结点的单链表 for (i=n; i&gt;0;--i)&#123; p=(LinkList)malloc(sizeof(LNode));//生成新结点 scanf(&amp;p-&gt;data);//输入元素值 p-&gt;next=L-&gt;next;L-&gt;next=p; //插入到表头/ &#125;&#125;//CreateList_L 头插法的幻想图插了一个想不明白就想两个节点 尾插法建立单链表思路① 建立新节点② 向新节点中添入内容③ 将新节点链入链尾④ 改变尾指针 代码12345678910111213void CreateList_L(LinkList &amp;L, int n) &#123; //输入n个元素的值，建立带表头结点的线性链表 L=（LinkList）malloc(sizeof (LNode)); L-&gt;next=NULL; //先建立一个带头结点的单链表 r=L; for (i=1; i&lt;=n;i++)&#123; p=(LinkList)malloc(sizeof(LNode));//生成新结点 scanf(&amp;p-&gt;data);//输入元素值 p-&gt;next=NULL; r-&gt;next=p; r=p; &#125;&#125;//CreateList_L 归并2个有序链表12345678910111213141516171819void MergeList_L(LinkList &amp;La, LinkList &amp;Lb, LinkList &amp;Lc)&#123; pa=La-&gt;next; pb=Lb-&gt;next; Lc=pc=La; //用La的头结点作为Lc的头结点 while(pa &amp;&amp; pb)&#123; if (pa-&gt;data&lt;=pb-&gt;data)&#123; pc-&gt;next=pa; pc=pa; pa=pa-&gt;next; &#125; else &#123; pc-&gt;next=pb; pc=pb; pb=pb-&gt;next; &#125; &#125; pc-&gt;next=pa?pa:pb;//插入剩余段 free(Lb);//释放Lb的头结点&#125;//MergeList_L 单链表结构的优缺点优点 动态结构，整个存储空间为多个链表共用 不需预先分配空间缺点 指针占用额外存储空间 不能随机存取，查找速度慢循环链表 在单链表中，将终端结点的指针域NULL改为指向表头结点的或开始结点，就得到了单链形式的循环链表，并简单称为单循环链表。 为了使空表和非空表的处理一致，循环链表中也可设置一个头结点。 由于循环链表中没有NULL指针，故涉及遍历操作时，其终止条件就不再像非循环链表那样判断p或p—&gt;next是否为空，而是判断它们是否等于头指针。双向链表结构定义12345typedef struct DulNode &#123; ElemType data; struct DuLNode *prior; struct DuLNode *next;&#125;DuLNode, *DuLinkList; 插入结点程序 1234567891011Status ListInsert_DuL(DuLinklist L, int i, ElemType e)&#123; DuLinklist s,p; if (!(p=GetElemP_DuL(L,i))) return ERROR; // 在L中确定第i个元素的位置指针p if(!(s = (DuLinklist)malloc(sizeof(DuLNode)))) return ERROR; s-&gt;data = e; // 构造数据为e的结点s s-&gt;prior = p-&gt;prior; p-&gt; prior -&gt;next = s; s-&gt;next = p; p-&gt;prior = s; return OK;&#125; // ListInsert_DuL 删除结点程序1234567891011Status ListDelete_DuL(DuLinklist L, int i, ElemType &amp;e)&#123; DuLinklist p; if (!(p=GetElemP_DuL(L,i))) return ERROR; // 在L中确定第i个元素的位置指针p e = p-&gt;data; // 删除的结点的值存入e p-&gt; prior -&gt;next = p-&gt;next; p-&gt;next-&gt;prior = p-&gt;prior; free(p); return OK;&#125; // ListDelete_DuL 带头结点的线性链表类型具有实用意义的线性链表 1234567891011typedef struct LNode // 结点类型&#123; ElemType data; LNode *next;&#125;*Link,*Position;struct LinkList // 链表类型&#123; Link head,tail; // 分别指向线性链表中的头结点和最后一个结点 int len; // 指示线性链表中数据元素的个数&#125;;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://daybreakland.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构 | 树-3 | 树和森林","slug":"6.3树和森林","date":"2019-12-03T05:03:55.000Z","updated":"2019-12-09T01:45:19.017Z","comments":true,"path":"2019/12/03/6.3树和森林/","link":"","permalink":"https://daybreakland.top/2019/12/03/6.3%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/","excerpt":"数的存储结构(表示法)、森林与二叉树的转换、树和森林的遍历、哈夫曼树","text":"数的存储结构(表示法)、森林与二叉树的转换、树和森林的遍历、哈夫曼树 树的存储结构双亲表示法取一块连续的内存空间，在存储每个结点的同时，各自都附加一个记录其双亲结点位置的变量。 代码实现12345typedef struct PTNode //结点结构&#123; ElemType data; int parent;//结点的父结点在数组中的位置下标&#125;PTNode; 孩子表示法将树中的每个结点的孩子结点排列成一个线性表，用链表存储起来。对于含有 n 个结点的树来说，就会有 n 个单链表，再把 n 个单链表的头指针存储在一个线性表中。如果结点没有孩子，则其单链表为空。 代码表示1234567891011121314151617typedef struct CTNode//每个节点的孩子链表&#123; int child; //数据在数组中存储的位置下标 struct CTNode *next;&#125;*ChildPtr;typedef struct //每个节点的信息&#123; TElemType data; ChildPtr firstchild; //孩子链表的头指针&#125;CTBox;typedef struct//全树&#123; CTBox nodes[Tree_Size]; //存储结点的数组 int n, r; //结点数量和树根的位置&#125;CTree; 孩子兄弟表示法（二叉树表示法） 代码表示 12345typedef struct CSNode&#123; ElemType data; struct CSNode *firstchild, *nextsibling;&#125;CSNode, *CSTree; 通过孩子兄弟表示法，普通树转化为了二叉树，所以孩子兄弟表示法又被称为“二叉树表示法”或者“二叉链表表示法”。 森林与二叉树转换将树转换成二叉树加线：在兄弟之间加一连线抹线：对每个结点，除了其左孩子外，去除其与其余孩子之间的关系旋转：以树的根结点为轴心，将整树顺时针转45° 将二叉树转换成树加线：若p结点是双亲结点的左孩子，则将p的右孩子，右孩子的右孩子，……沿分支找到的所有右孩子，都与p的双亲用线连起来抹线：抹掉原二叉树中双亲与右孩子之间的连线调整：将结点按层次排列，形成树结构 森林转换成二叉树将各棵树分别转换成二叉树将每棵树的根结点用线相连以第一棵树根结点为二叉树的根，再以根结点为轴心，顺时针旋转，构成二叉树型结构 二叉树转换成森林抹线：将二叉树中根结点与其右孩子连线，及沿右分支搜索到的所有右孩子间连线全部抹掉，使之变成孤立的二叉树还原：将孤立的二叉树还原成树 树和森林的遍历树的遍历遍历按一定规律走遍树的各个顶点，且使每一顶点仅被访问一次，即找一个完整而有规律的走法，以得到树中所有结点的一个线性排列 常用方法 先根（序）遍历：先访问树的根结点，然后依次先根遍历根的每棵子树 后根（序）遍历：先依次后根遍历每棵子树，然后访问根结点 按层次遍历：先访问第一层上的结点，然后依次遍历第二层，……第n层的结点森林遍历 先序遍历森林若森林非空：访问森林中第一棵树的根结点；先序遍历第一棵树根结点的子树森林；先序遍历除第一棵树后剩余的树构成的森林； 中序遍历森林若森林非空：中序遍历第一棵树根结点的子树森林；访问第一棵树的根结点；中序遍历除第一棵树后剩余的树构成的森林；哈夫曼树(Huffman)带权路径长度最短的树基本概念 路径：从树中一个结点到另一个结点之间的分支构成这两个结点间的~ 路径长度：路径上的分支数目 树的路径长度：从树根到每一个结点的路径长度之和 树的带权路径长度：树中所有带权叶子结点的路径长度之和Huffman树设有n个权值{w1,w2,……wn}，构造一棵有n个叶子结点的二叉树，每个叶子的权值为wi,则wpl最小的二叉树叫Huffman树Huffman算法 构造Huffman树步骤》根据给定的n个权值{w1,w2,……wn}，构造n棵只有根结点的二叉树，令其权值为wj。》在森林中选取两棵根结点权值最小的树作左右子树，构造一棵新的二叉树，置新二叉树根结点权值为其左右子树根结点权值之和。》在森林中删除这两棵树，同时将新得到的二叉树加入森林中。》重复上述两步，直到只含一棵树为止，这棵树即哈夫曼树。Huffman编码哈弗曼编码是数据通信用的二进制编码 思想：根据字符出现频率编码，使电文总长最短 编码：根据字符出现频率构造Huffman树，然后将树中结点引向其左孩子的分支标“0”，引向其右孩子的分支标“1”（左0右1）；每个字符的编码即为从根到每个叶子的路径上得到的0、1序列","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://daybreakland.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构 | 树-2 | 遍历二叉树","slug":"6.2遍历二叉树","date":"2019-12-03T05:03:42.000Z","updated":"2019-12-09T01:45:11.418Z","comments":true,"path":"2019/12/03/6.2遍历二叉树/","link":"","permalink":"https://daybreakland.top/2019/12/03/6.2%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"建树、前中后序遍历二叉树、线索二叉树","text":"建树、前中后序遍历二叉树、线索二叉树 遍历二叉树树的常见操作建树123456789101112131415161718Status CreateBiTree(BiTree &amp;T) &#123; // 算法6.4:按先序次序输入二叉树中结点的值（可为字符型或整型，在主程中 // 定义），构造二叉链表表示的二叉树T。变量Nil表示空（子）树。有改动 TElemType ch; cin&gt;&gt;ch; if(ch==Nil) // 空 T=NULL; else &#123; T=(BiTree)malloc(sizeof(BiTNode)); if(!T) exit(OVERFLOW); T-&gt;data=ch; // 生成根结点 CreateBiTree(T-&gt;lchild); // 构造左子树 CreateBiTree(T-&gt;rchild); // 构造右子树 &#125; &#125; 求树的深度123456789101112131415int BiTreeDepth(BiTree T) &#123; // 初始条件: 二叉树T存在。操作结果: 返回T的深度 int i,j; if(!T) return 0; if(T-&gt;lchild) i=BiTreeDepth(T-&gt;lchild); else i=0; if(T-&gt;rchild) j=BiTreeDepth(T-&gt;rchild); else j=0; return i&gt;j?i+1:j+1; &#125; 插入子树123456789101112131415161718192021Status InsertChild(BiTree p,int LR,BiTree c) // 形参T无用 &#123; // 初始条件: 二叉树T存在,p指向T中某个结点,LR为0或1,非空二叉树c与T // 不相交且右子树为空 // 操作结果: 根据LR为0或1,插入c为T中p所指结点的左或右子树。p所指结点的 // 原有左或右子树则成为c的右子树 if(p) // p不空 &#123; if(LR==0) &#123; c-&gt;rchild=p-&gt;lchild; p-&gt;lchild=c; &#125; else // LR==1 &#123; c-&gt;rchild=p-&gt;rchild; p-&gt;rchild=c; &#125; return OK; &#125; return ERROR; // p空 &#125; 前序递归遍历二叉树12345678910void PreOrderTraverse(BiTree T,Status(*Visit)(TElemType)) &#123; // 初始条件: 二叉树T存在,Visit是对结点操作的应用函数。算法6.1，有改动 // 操作结果: 先序递归遍历T,对每个结点调用函数Visit一次且仅一次 if(T) // T不空 &#123; Visit(T-&gt;data); // 先访问根结点 PreOrderTraverse(T-&gt;lchild,Visit); // 再先序遍历左子树 PreOrderTraverse(T-&gt;rchild,Visit); // 最后先序遍历右子树 &#125; &#125; 前中后序的递归算法只是更改了visit(T-&gt;data)语句位置，前中后分别对应位置1、2、3 中序遍历二叉树1234567891011121314Status InOrderTraverse( BiTree T, status (*visit)(TElemType e ))&#123; InitStack( S ); Push( S, T ); // 根指针进栈 while( ! StackEmpty( S ))&#123; while( GetTop( S, p ) &amp;&amp; p ) Push( S, p-&gt;lChild );//向左，直到最左下角 Pop( S, p ); // NULL退栈 if( !StackEmpty( S))&#123; Pop( S, p ); // 根退出 if( ! ( *Visit)(p-&gt;data) ) return ERROR; Push( S, p-&gt;RChild ); &#125;// if &#125;// while return OK;&#125;// InOrderTraverse 二叉树的计数由二叉树的前序序列和中序序列可唯一地确定一棵二叉树。 线索二叉树定义前驱与后继在二叉树的先序、中序或后序遍历序列中两个相邻的结点互称为~ 线索指向前驱或后继结点的指针称为~ 线索二叉树加上线索的二叉链表表示的二叉树叫~ 线索化对二叉树按某种遍历次序使其变为线索二叉树的过程叫~ 实现 在有n个结点的二叉链表中必定有n+1个空链域 在二叉树或二叉链表中，若左孩子为空，则画出它的直接前驱，右孩子为空时，则画出它的直接后继，左右孩子不为空时，不需画前驱和后继。这样就得到了线索二叉树或线索二叉链表。对应tag为0，child域指向孩子；对应tag为1，child域指向孩子。中序线索二叉树线索二叉树的遍历线索链表的遍历算法 附带习题1 编写求二叉树的分枝结点个数的算法（用二叉链表存） 2 二叉树求二叉树深度算法","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://daybreakland.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构 | 树-1 | 树和二叉树","slug":"6.1树和二叉树","date":"2019-12-03T05:03:08.000Z","updated":"2019-12-09T01:44:16.356Z","comments":true,"path":"2019/12/03/6.1树和二叉树/","link":"","permalink":"https://daybreakland.top/2019/12/03/6.1%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"树和二叉树的基本概念、特殊二叉树、二叉树的存储结构","text":"树和二叉树的基本概念、特殊二叉树、二叉树的存储结构 树的定义和基本概念定义树(tree)是n(n&gt;0)个结点的有限集T，其中：有且仅有一个特定的结点，称为树的根(root)当n&gt;1时，其余结点可分为m(m&gt;0)个互不相交的有限集T1,T2,……Tm，其中每一个集合本身又是一棵树，称为根的子树(subtree) 特点：树中至少有一个结点——根树中各子树是互不相交的集合基本术语结点(node)指树中的一个数据元素，包括数据项及若干指向其子树的分支。一般用一个字母表示。结点的度(degree)结点拥有的子树数叶子(leaf)度为0的结点，也叫终端结点。 分枝结点除叶子结点外的所有结点，也叫非终端结点。孩子(child)结点子树的根称为该结点的孩子双亲(parents)孩子结点的上层结点叫该结点的~祖先结点从根结点到该结点所经过分枝上的所有结点为该结点的祖先，如图6-1c中M的祖先有A，D ，H 。子孙结点某一结点的子女及子女的子女都为该结点子孙。兄弟(sibling)具有同一个双亲的结点树的度一棵树中最大的结点度数结点的层次(level)从根结点算起，根为第一层，它的孩子为第二层……深度(depth)树中结点的最大层次数有序树若一棵树中所有子树从左到右的排序是有顺序的，不能颠倒次序。称该树为有序树。无序树若一棵树中所有子树的次序无关紧要，则称为无序树。森林(forest)m(m&gt;=0)棵互不相交的树的集合.一棵树可以看成是一个特殊的森林。ADT 12345678910111213141516171819202122232425262728ADT Tree&#123; 数据对象D：D是具有相同特性的数据元素的集合 数据关系R： 若D为空集，则称为空树； 若D仅含一个数据元素，则R为空集，否则R=&#123;H&#125;， H是如下二元关系： 在D中存在唯一的称为根的数据元素root，它在关系H下无前驱； 若D-&#123;root&#125;≠Φ,则存在D-&#123;root&#125;的一个划分D1,D2,…Dm(m&gt;0)，对任意j≠k (1≤j,k≤m)又Dj∩Dk=Φ,且对任意的i(1≤i≤m)，唯一存在数据元素xi∈Di，有&lt;root,xi&gt;∈H; 对应于D-&#123;root&#125;的划分，H - &#123;&lt;root,x1&gt;, … &lt;root , xm&gt; &#125; 有唯一的一个划分H1,H2,…Hm，m&gt;0，对任意j≠k(1≤j,k≤m)有Hj∩Hk=Φ，且对任意i（1≤i≤m），Hi是Di上的二元关系，(Di,&#123;Hi&#125;）是一棵符合本定义的树，称为根root的子树。 基本操作： InitTree( &amp;T ); // 初始化 DestroyTree( &amp;T ); // 销毁 CreateTree( &amp;T, definition);//按definition构造树 ClearTree( &amp;T ); // 清空 TreeEmpty( T ); // 空？ TreeDepth( T ); // 树的深度 Root( T ); // 树根 Value( T, cur_e ); // 求结点cur_e的值 Assign( T, cur_e, value ); // 赋值 Parent( T, cur_e ); // 求cur_e的双亲 LeftChild( T, cur_e ); // 求cur_e的最左孩子 RightSibling( T, cur_e );// 求cur_e的右兄弟 InsertChild( &amp;T, &amp;p, i, c );// 插入c为T中p所指结点的第i棵子树 DeleteChild( &amp;T, &amp;p, i);// 删除T中，p所指结点的第i个子树 TraverseTree( T, visit() ); //遍历 &#125;//ADT Tree 二叉树定义二叉树是n(n&gt;=0)个结点的有限集，它或为空树(n=0)，或由一个根结点和两棵分别称为左子树和右子树的互不相交的二叉树构成 特点每个结点至多有二棵子树(即不存在度大于2的结点)二叉树的子树有左、右之分，且其次序不能任意颠倒二叉树的ADT表示 123456789101112131415161718192021222324252627282930313233343536373839ADT BinaryTree&#123; 数据对象D：D是具有相同特性的数据元素的集合； 数据关系R: 若D = Φ，则 R = Φ， 称BinaryTree为空二叉树； 若D ≠ Φ，则 R = &#123; H &#125;, H是如下的二元关系： (1) 在D中，存在唯一的称为根的数据元素 root, 它在关系H下无前驱； (2) 若D – &#123;root&#125; ≠ Φ, 则存在 D-&#123;root&#125; = &#123;Dl, Dr&#125;, 且 Dl ∩Dr = Φ； (3) 若Dl ≠ Φ, 则Dl中存在唯一的元素xl, &lt;root, xl&gt; ∈ H, 且存在Dl上的关系Hl ∈H； 若Dr ≠ Φ,则Dr中存在唯一的元素xr,&lt;root,xr&gt;∈H, 且存在Dr上的关系Hr ∈H； H = &#123; &lt;root, xl&gt;,&lt;root, xr&gt;, Hl, Hr&#125;; (4) ( Dl,&#123; Hl&#125;)是一棵符合本定义的二叉树，称为根的左子树； ( Dr, &#123;Hr&#125;)是一棵符合本定义的二叉树，称为根的右子树； 基本操作： InitBiTree( &amp;T ); // 初始化 DestroyBiTree( &amp;T ); // 销毁 CreateBiTree( &amp;T, definition ); // 创建二叉树 ClearBiTree( &amp;T ); // 清空 BiTreeEmpty( T ); // 空？ BiTreeDepth( T ); // 深度 Root( T ); // 根 Value( T, e ); // 求e的值 Assign( T, &amp;e, value ); // 赋值 Parent( T, e ); // 求双亲 LeftChild( T, e ); // 左孩子 RightChild( T, e ); // 右孩子 LeftSibling( T, e) ; // 左兄弟 RightSibling( T, e ); // 右兄弟 InsertChild( T, p, LR, c ); // 插入 DeleteChild( T, p, LR ); // 删除 PreOrderTraverse( T, Visit( )); // 先序遍历 InOrderTraverse( T, Visit( )); // 中序遍历 PostOrderTraverse( T, Visit( )); // 后序遍历 LeverOrderTraverse( T, Visit( )); // 层序遍历&#125; // ADT BinaryTree 二叉树的性质 性质1：在二叉树的第i层上至多有2^(i-1)个结点(i≥1) 性质2：深度为k的二叉树至多有2^(k-1)个结点(k≥1) 性质3：对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1 性质4：具有n个结点的完全二叉树的深度为floor[ log2 n ] +1 性质5：如果对一棵有n个结点的完全二叉树的结点按层序编号，则对任一结点i(1&lt;=i&lt;=n)，有：(1) 如果i=1，则结点i是二叉树的根，无双亲；如果i&gt;1，则其双亲是florr[i/2](2) 如果2i&gt;n，则结点i无左孩子；如果2i&lt;=n，则其左孩子是2i(3) 如果2i+1&gt;n，则结点i无右孩子；如果2i+1&lt;=n，则其右孩子是2i+1 特殊的二叉树满二叉树深度为k，其一共有2^(k)-1个节点（每一层都满了） 完全二叉树深度为k，有n个结点的二叉树当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应（最后一层，从最右节点去掉连续节点后的满二叉树） 二叉树的存储结构顺序存储结构更适合存储完全二叉树，一般二叉树会浪费空间 链式存储结构二叉链表1234typedef struct BitNode&#123; TElemType data; struct BitNode *lchild,*rchild;&#125;BiTNode,*BiTree; 三叉链表1234typedef struct node&#123; Elemtype data; struct node *lchild,*rchild,*parent;&#125;;BiTNode, *BiTree;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://daybreakland.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构 | 绪论","slug":"1.0绪论","date":"2019-12-03T04:59:51.000Z","updated":"2019-12-09T01:43:50.718Z","comments":true,"path":"2019/12/03/1.0绪论/","link":"","permalink":"https://daybreakland.top/2019/12/03/1.0%E7%BB%AA%E8%AE%BA/","excerpt":"什么是数据结构、基本概念术语、算法和算法分析、渐进时间复杂度","text":"什么是数据结构、基本概念术语、算法和算法分析、渐进时间复杂度 主要内容 什么是数据结构 一些基本概念和术语 算法和算法分析 时间复杂度的渐进表示法 什么是数据结构 程序=数据结构+算法 数据结构是一门研究非数值计算的程序设计问题中计算机的操作对象以及它们之间的关系和操作等等的学科 基本概念和术语数据（data)所有能输入到计算机中去的描述客观事物的符号数据元素（data element）数据的基本单位，也称节点（node）或记录（record）。 有时一个数据元素可以由若干数据项(Data Item)组成。数据项（data item）有独立含义的数据最小单位，也称域(field)数据结构（data structure)数据元素和数据元素关系的集合 （带结构的数据元素的集合）四种基本数据结构集合——数据元素间除“同属于一个集合”外，无其它关系线性结构——一个对一个，如线性表、栈、队列树形结构——一个对多个，如树图状结构——多个对多个，如图 数据结构的表示图示表示图示表示是由顶点和边构成的图，其中顶点表示数据,边表示数据之间的结构关系； 二元组表示数据结构的形式定义为：数据结构是一个二元组： Data-Structure=(D，S)其中：D是数据元素的有限集，S是D上关系的有限集。 一些基本概念和术语数据结构的三个主要问题 数据的逻辑结构只抽象反映数据元素的逻辑关系 数据的存储（物理）结构数据的逻辑结构在计算机存储器中的实现 数据的逻辑结构与存储结构密切相关 算法设计-&gt; 逻辑结构 算法实现-&gt; 存储结构 数据的逻辑结构数据的存储结构存储结构分为： 顺序存储结构——借助元素在存储器中的相对位置来表示数据元素间的逻辑关系 链式存储结构——借助指示元素存储地址的指针表示数据元素间的逻辑关系 抽象数据类型ADT1234567ADT 抽象数据类型名&#123; 数据对象：&lt;数据对象的定义&gt; 数据关系：&lt;数据关系的定义&gt; 基本操作：基本操作名（参数表） 初始条件：&lt;初始条件描述&gt; 操作结果：&lt;操作结果描述&gt; &#125;ADT 抽象数据类型名 算法和算法分析算法的概念解决某一特定问题的具体步骤的描述，是指令的有限序列.其中每一条指令表示一个或多个操作。 算法的特性1 有穷性一个算法必须总是在执行有穷步之后结束，且每一步都在有穷时间内完成。 2 确定性算法中每一条指令必须有确切的含义。不存在二义性。且算法只有一个入口和一个出口。 3 可行性一个算法是可行的。即算法描述的操作都是可以通过已经实现的基本运算执行有限次来实现的。 4 输入 一个算法有零个或多个输入，这些输入取自于某个特定的对象集合。 5 输出 一个算法有一个或多个输出，这些输出是同输入有着某些特定关系的量。 算法的评价标准1 正确性(Correctness)算法应满足具体问题的需求。 2 可读性(Readability)算法应该好读。以有利于阅读者对程序的理解。 3 健壮性(Robustness)算法应具有容错处理。当输入非法数据时，算法应对其作出反应，而不是产生莫名其妙的输出结果。 4 效率与存储量需求效率指的是算法执行的时间；存储量需求指算法执行过程中所需要的最大存储空间。一般，这两者与问题的规模有关。 算法时间复杂度通常用程序中基本操作的执行次数来做为程序执行时间的评估值，并取问题规模作为自变量T(n)称作算法的渐近时间复杂度。很多算法的时间复杂度不仅与问题的规模有关，而且还与它所处理的数据集的状态有关。通常是根据数据集中可能出现的最坏情况估计出算法的最坏时间复杂度。 空间复杂度 程序所用的存储空间包括两个部分:(1)固定部分这部分空间的大小与输入输出的个数多少、数值大小无关。(2)可变部分这部分空间主要包括其尺寸与实例特征有关的成分变量所占空间、引用变量所占空间、以及递归栈所用的空间，还有算法运行时动态命令使用的空间。","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://daybreakland.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构 | 图-6 | 最短路径","slug":"7.6最短路径","date":"2019-11-27T09:34:58.000Z","updated":"2019-12-09T01:46:10.359Z","comments":true,"path":"2019/11/27/7.6最短路径/","link":"","permalink":"https://daybreakland.top/2019/11/27/7.6%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/","excerpt":"迪杰斯特拉算法、弗洛伊德算法","text":"迪杰斯特拉算法、弗洛伊德算法 用带权的有向图表示一个交通运输网，图中： 顶点——表示城市 边——表示城市间的交通联系 权——表示此线路的长度或沿此线路运输所花的时间或费用等 问题：从某顶点出发，沿图的边到达另一顶点所经过的路径中，各边上权值之和最小的一条路径——最短路径。 从某个源点到其余各顶点的最短路径 方法一：迪杰斯特拉(Dijkstra)算法算法思想 首先，在这些最短路径中，长度最短的这条路径上必定只有一条弧，且它的权值是从源点出发的所有弧上权的最小值。 其次，第二条长度次短的最短路径只可能有两种情况： 1)或者只含一条从源点出发的弧且小于其它从源点出发的弧上的权值； 2)或者是一条只经过已求得最短路径的顶点的路径。 依次类推，按迪杰斯特拉算法先后求得的每一条最短路径必定只有两种情况，或者是由源点直接到达终点，或者是只经过已经求得最短路径的顶点到达终点。 求最短路径步骤 初使时令 S={V0},T={其余顶点}，T中顶点对应的距离值 若存在&lt;V0,Vi&gt;，为&lt;V0,Vi&gt;弧上的权值若不存在&lt;V0,Vi&gt;，为 从T中选取一个其距离值为最小的顶点W，加入S. 对T中顶点的距离值进行修改：若加进W作中间顶点，从V0到Vi的距离值比不加W的路径要短，则修改此距离值 重复上述步骤，直到S中包含所有顶点，即S=V为止 方法二：弗洛伊德(Floyd)算法算法思想逐个顶点试探法求最短路径步骤 初始时设置一个n阶方阵，令其对角线元素为0，若存在弧&lt;Vi,Vj&gt;，则对应元素为权值；否则为 逐步试着在原直接路径中增加中间顶点，若加入中间点后路径变短，则修改之；否则，维持原值 所有顶点试探完毕，算法结束","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://daybreakland.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构 | 图-5 | 拓扑排序","slug":"7.5拓扑排序及关键路径","date":"2019-11-27T09:14:58.000Z","updated":"2019-12-09T01:46:01.426Z","comments":true,"path":"2019/11/27/7.5拓扑排序及关键路径/","link":"","permalink":"https://daybreakland.top/2019/11/27/7.5%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E5%8F%8A%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/","excerpt":"拓扑排序、关键路径","text":"拓扑排序、关键路径 拓扑排序背景 顶点——表示课程 有向弧——表示先决条件，若课程i是课程j的先决条件，则图中有弧&lt;i,j&gt; 拓扑排序学生应按怎样的顺序学习这些课程，才能无矛盾、顺利地完成学业定义AOV网用顶点表示活动，用弧表示活动间优先关系的有向图称为顶点表示活动的网(Activity On Vertex network)，简称AOV网。 若&lt;vi,vj&gt;是图中有向边，则vi是vj的直接前驱，vj是vi的直接后继；AOV网中不允许有回路，这意味着某项活动以自己为先决条件； 拓扑排序的定义把AOV网络中各顶点按照它们相互之间的优先关系排列成一个线性序列的过程叫拓扑排序 -拓扑排序应用检测AOV网中是否存在环：对有向图构造其顶点的拓扑有序序列，若网中所有顶点都在它的拓扑序列，则该AOV网必定无环 方法 在有向图中选一个没有前驱的顶点且输出之； 从图中删除该顶点和所有以它为尾的弧； 重复上述两步，直至全部顶点均已输出，或图中不存在无前驱的顶点。算法实现以邻接表作存储结构, 把邻接表中所有入度为0的顶点进栈; 栈非空时，输出栈顶元素Vj并退栈； 在邻接表中查找Vj的直接后继Vk，把Vk的入度减1；若Vk的入度为0则进栈; 重复上述操作直至栈空为止。 若栈空时输出的顶点个数不是n，则有向图有环；否则，拓扑排序完毕 1234567891011121314151617181920Status TopologicalSort(ALGraph G) &#123; for(i = 0;i &lt;G.vexnum; ++ i ) //查找入度为为零的顶点 if(! Indegree[i]) //把入度为零的顶点进栈 push (S,i ); count = 0; //计数器置0 while (! StackEmpty(s)) &#123; pop(s, i); printf(i,Gvextices[i].data); ++count;//输出顶点、计数 for(p=G.vextices[i].firstarc; p ; p = p-&gt;nextarc) &#123; k = p-&gt;adjvex; //得到与输出顶点相邻接的顶点下标 if(! (--indegree[k])) push( S,k); //将邻接点的入度减1，将为零的入栈 &#125;//for &#125;//while if (count&lt;G.vexnum) return ERROR;//该图有回路 else return OK;&#125;//TopologicalSort 关键路径背景 把工程计划表示为有向图，用顶点表示事件，弧表示活动；每个事件表示在它之前的活动已完成，在它之后的活动可以开始；事件 V1——表示整个工程开始事件 V9——表示整个工程结束其中，T为所有以第j个顶点为头的弧的集合。 定义AOE网(Activity On Edge)边表示活动的网。AOE网是一个带权的有向无环图，其中顶点表示事件，弧表示活动，权表示活动持续时间 路径长度路径上各活动持续时间之和。 关键路径路径长度最长的路径叫关键路径。 Ve——事件Vj的最早发生时间Ve(j) 源点的最早发生时间为0，其余任一顶点Vj的最早发生时间，等于从源点出发沿着各条路径达到Vj时每条路径上权的累加和的最大值。计算公式为：**Ve(j)=Max{ve(i) + dut(&lt;i ,j&gt;)} &lt;i,j&gt;∈T, j = 1,2,3…n-1** Vl—事件的最迟发生时间Vl(j) 汇点的最迟发生时间Vl[n]等于汇点的最早发生时间Ve[n]。其余任一顶点Vi的最迟发生时间等于从汇点的最迟发生时间中减去从顶点Vi出发沿着各条路径达到汇点时，每条路径上权的累加和的最大值。最迟发生时间一般用下列公式计算: Vl(i)=Min{vl(j)-dut(&lt;i ,j&gt;)} &lt;i,j&gt; ∈S, i = n -2,..,0其中， S为所有以第i个顶点为尾的弧的集合。 e(i)——表示活动ai的最早开始时间l(i)——表示活动ai的最迟开始时间 设活动ai用弧&lt;j,k&gt;表示， 其持续时间记为：dut(&lt;j,k&gt;) 则有：（1）e(i)=Ve(j) //最早开始时间是弧尾事件的最早发生时间 （2）l(i)=Vl(k)-dut(&lt;j,k&gt;)//最迟开始时间是弧头事件的最晚发生时间减去活动的持续时间，即弧的权值 l(i)-e(i)——表示完成活动ai的时间余量 关键活动——关键路径上的活动叫关键活动，即l(i)=e(i)的活动 算法实现描述 输入顶点和弧信息，建立其邻接表 计算每个顶点的入度 对其进行拓扑排序 排序过程中求顶点的Ve[i] 将得到的拓扑序列进栈 按逆拓扑序列求顶点的Vl[i] 计算每条弧的e[i]和l[i],找出e[i]=l[i]的关键活动……没看，待更新","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://daybreakland.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构 | 图-4 | 图的连通性问题","slug":"7.4图的连通性问题","date":"2019-11-26T14:39:58.000Z","updated":"2019-12-09T01:45:52.760Z","comments":true,"path":"2019/11/26/7.4图的连通性问题/","link":"","permalink":"https://daybreakland.top/2019/11/26/7.4%E5%9B%BE%E7%9A%84%E8%BF%9E%E9%80%9A%E6%80%A7%E9%97%AE%E9%A2%98/","excerpt":"最小生成树普里姆算法、克鲁斯卡尔算法","text":"最小生成树普里姆算法、克鲁斯卡尔算法 最小生成树问题提出要在n个城市间建立通信联络网，顶点——表示城市权——城市间建立通信线路所需花费代价希望找到一棵生成树，它的每条边上的权值之和（即建立该通信网所需花费的总代价）最小———最小代价生成树 n个城市间，最多可设置n(n-1)/2条线路 n个城市间建立通信网，只需n-1条线路 问题转化为：如何在可能的线路中选择n-1条，能把 所有城市（顶点）均连起来，且总耗费 （各边权值之和）最小构造最小生成树方法普里姆(Prim)算法/T(n)=O(V²)算法思想： 设连通网N=(V,{E}),点集U为已处理点集，最小生成树边集TE。 初始任取一点，加入U，使U={v0}； 在所有u∈U,v∈V-U的边(u,v)∈E中，找一条代价最小的边(u0,v0) 两点确定一条边，即在所有生成树邻接的边里找条最小的。 将(u0,v0)并入集合TE，同时v0并入U 把边并入生成树，点并入已处理点集。 重复操作直至U=V。克鲁斯卡尔(Kruskal)算法/O(E log E)算法思想： 设连通网N=(V,{E})，初始状态为只有n个顶点而无边的非连通图T=(V,{∅})，每个顶点自成一个连通分量 在E中选取代价最小的边，若该边依附的顶点落在T中不同的连通分量上，则将此边加入到T中； 否则，舍去此边，选取下一条代价最小的边依此类推，直至T中所有顶点都在同一连通分量上为止。 一开始所有点各自独立，遍历E集合选代价最小边，若该边的两个顶点落在不同连通分量上，就加进T，直到T里所有顶点全在一个连通分量上。","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://daybreakland.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构 | 图-3 | 图的遍历","slug":"7.3图的遍历","date":"2019-11-26T14:38:52.000Z","updated":"2019-12-09T01:45:45.631Z","comments":true,"path":"2019/11/26/7.3图的遍历/","link":"","permalink":"https://daybreakland.top/2019/11/26/7.3%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/","excerpt":"BFS、DFS","text":"BFS、DFS 深度优先遍历(DFS) 从图的某一顶点V0出发，访问此顶点；然后依次从V0的未被访问的邻接点出发，深度优先遍历图，直至图中所有和V0相通的顶点都被访问到；若此时图中尚有顶点未被访问，则另选图中一个未被访问的顶点作起点，重复上述过程，直至图中所有顶点都被访问为止 123456789101112131415161718192021222324//--- 下列算法使用的全局变量 ---Boolean visited[MAX]; // 访问标志数组Status (* VisitFunc)(int v); // 函数变量void DFS(Graph G, int v) &#123;// 从第v个顶点出发递归地深度优先遍历图G。 visited[v] = TRUE; VisitFunc(v); // 访问第v个顶点 for(w=FirstAdjVex(G,v);w!=0;w=NextAdjVex(G,v,w)) if(!visited[w]) DFS(G, w); // 对v的尚未访问的邻接顶点w递归调用DFS&#125;void DFSTraverse(Graph G, Status (*Visit)(int v)) &#123; // 对图G作深度优先遍历。 VisitFunc = Visit; for (v=0; v&lt;G.vexnum; ++v) visited[v] = FALSE; // 访问标志数组初始化 for (v=0; v&lt;G.vexnum; ++v) if (!visited[v]) DFS(G, v); // 对尚未访问的顶点调用DFS&#125; 广度优先遍历(BFS) 从图的某一顶点V0出发，访问此顶点后，依次访问V0的各个未曾访问过的邻接点；然后分别从这些邻接点出发，广度优先遍历图，直至图中所有已被访问的顶点的邻接点都被访问到；若此时图中尚有顶点未被访问，则另选图中一个未被访问的顶点作起点，重复上述过程，直至图中所有顶点都被访问为止 1234567891011121314151617181920void BFSTraverse( Graph G, status (*visit )(int v )) &#123; for( v = 0; v &lt; G.vexnum; ++v) visited[v] = FALSE; InitQueue( Q ); for( v = 0; v &lt; G.vexnum; ++ v) if( !visited[v] )&#123; visited[v] = TRUE; visit( v ); EnQueue( Q, v ); while( !QuqueEmpty( Q)) &#123; Dequeue( Q, u ); for(w=FirstAdjVex(G,u);w;w=NextAdjVex(G,u,w)) if( !Visited[w] )&#123; Visited[w]=TRUE; Visit( w ); Enqueue(Q,w); &#125;// if &#125;// while &#125;// if&#125;// BFSTraverse","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://daybreakland.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构 | 图-2 | 图的存储结构","slug":"7.2图的存储结构","date":"2019-11-26T14:38:30.000Z","updated":"2019-12-09T01:51:40.823Z","comments":true,"path":"2019/11/26/7.2图的存储结构/","link":"","permalink":"https://daybreakland.top/2019/11/26/7.2%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/","excerpt":"邻接矩阵、邻接多重表邻接表、逆邻接表、十字链表","text":"邻接矩阵、邻接多重表邻接表、逆邻接表、十字链表 数组表示法(邻接矩阵表示)有向图的邻接矩阵表示：无向图中顶点Vi的度TD(Vi)是邻接矩阵A中第 i 行元素之和. 邻接表 无向图中顶点Vi的度为第i个单链表中的结点数 无向图的邻接表 有向图中顶点Vi的出度为第i个单链表中的结点个数顶点Vi的入度为整个单链表中邻接点域值是i的结点个数 逆邻接表：有向图中对每个结点建立以Vi为头的弧的单链表有向图的邻接表和逆邻接表 有向图的十字链表表示法十字链表是有向图的一种存贮方式其中，图中的顶点用顶点结点单元表示。弧用弧结点单元表示。 弧节点单元 tailvex / headvex: 尾/头域：弧尾和弧头两个顶点在图中的位置 hlink: 弧头相同的下一条弧 tlink: 弧尾相同的下一条弧 info: 该弧的相关信息顶点节点单元 firstin: 顶点为弧头的第一个弧结点；//可求入度 firstout: 顶点为弧尾的第一个弧结点；//可求出度 data: 该结点的相关信息表示样例对第一个结点而言，蓝色线串起了以1为弧头的弧，绿线串起了以1为弧尾的弧无向图邻接多重表表示法邻接多重表是无向图的一种存贮方式其中，图中的顶点用顶点结点单元表示。边用边节点单元表示。与邻接表的差别在于 ，邻接表用2个顶点表示一条边，而邻接多重表用1个顶点表示一条边。边节点单元 mark,访问标志； ivex/jvex:边依符的两个顶点的位置； ilink/jlink:两个顶点的下一条边； info:边的信息顶点节点单元表示样例","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://daybreakland.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Hexo+github搭建博客纪实","slug":"Hexo-github搭建博客纪实","date":"2019-11-25T14:57:23.000Z","updated":"2019-11-26T06:54:53.111Z","comments":true,"path":"2019/11/25/Hexo-github搭建博客纪实/","link":"","permalink":"https://daybreakland.top/2019/11/25/Hexo-github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%BA%AA%E5%AE%9E/","excerpt":"简单记述了搭建博客的过程，类似Debug的过程，马克了期间参考的资料，之后应该会持续更新功能。","text":"简单记述了搭建博客的过程，类似Debug的过程，马克了期间参考的资料，之后应该会持续更新功能。 Hexo+github搭建博客纪实一、注册github仓库二、环境搭建&#8195;1.下载node.js和git&#8195;&#8195;&#8195;git bash（用于授权SHH和安装hexo系列操作） &#8195;2.SHH授权&#8195;&#8195;&#8195;公钥与秘钥 三、Hexo系列操作&#8195;1.下载安装&#8195;2.初始化+本地预览&#8195;&#8195;&#8195;自然要换好看的主题 &#8195;3.上传到github四、域名转接&#8195;1.购买域名&#8195;2.在github设置domain五、搭建过程&#8195;1.参考教程 流程（系统）https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html#%E4%BD%BF%E7%94%A8hexo%E5%86%99%E5%8D%9A%E5%AE%A2 流程（易懂）https://www.cnblogs.com/trista222/p/8017300.html 域名绑定https://blog.csdn.net/mqdxiaoxiao/article/details/92799543&#8195;2.DebugERROR1 “the CNAME is already taken” 问题描述： 搭建完博客，每次更新之后，使用域名地址访问博客都会404报错并且github邮箱账户会收到一封Waring Email： The page build completed successfully, but returned the following warning for the ‘master’ branch:Your CNAME file was ignored because this repository is automatically hosted from yourUsername.github.io already. See https://help.github.com/articles/setting-up-your-pages-site-repository/For information on troubleshooting Jekyll see: https://help.github.com/articles/troubleshooting-jekyll-buildsIf you have any questions you can contact us by replying to this email. https://wangqy.cc/2018/05/26/CNAME/ 咱也不知道发生了啥，咱也不造去哪儿问，网上搜罗了下，发现了相同情况了老哥：https://wangqy.cc/2018/05/26/CNAME/原因是 setting 下 github pages 的 custom domain 清空了，需要重新设置来生成 CNAME 文件。我们的初步解决方案，便是每次更新完去github仓库的settings里把domain调成自己的域名。 然而人是贪婪的，也是懒的，次次更新次次调设置太繁琐了，于是又摸索了下，受名为saucxs的大佬文章启发：https://www.cnblogs.com/chengxs/p/7496265.html找到了进阶解决方案，修改_config.yml文件： `# URLurl: daybreakland.top【原来这里是“yourUsername.github.io”】root: /permalink: :year/:month/:day/:title/permalink_defaults:pretty_urls: trailing_index: true # Set to false to remove trailing index.html from permalinks 这样就算是彻底解决了问题。 &#8195;3.功能和技巧 19.11.23 插入图片https://blog.csdn.net/L_201607/article/details/81176439 19.11.23 插入占位符 123&amp;#8195;一个中文的占位符&amp;#8194;半个中文的占位符&amp;#8197;四分之一的中文占位符","categories":[],"tags":[]},{"title":"数据结构 | 图-1 | 图的定义和术语","slug":"7.1图的定义和术语","date":"2019-11-25T13:18:14.000Z","updated":"2019-12-09T01:45:30.103Z","comments":true,"path":"2019/11/25/7.1图的定义和术语/","link":"","permalink":"https://daybreakland.top/2019/11/25/7.1%E5%9B%BE%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E6%9C%AF%E8%AF%AD/","excerpt":"本篇记录了数据结构图这一章学习的第一部分，即图的定义和术语。","text":"本篇记录了数据结构图这一章学习的第一部分，即图的定义和术语。 有向图 顶点：数据 弧表示方法：&lt;v,w&gt;有序对 弧头 v 弧尾 w无向图 边 表示方法：（v,m）无序对&lt;&gt; 如何表示一个无向图？G1 =(V1 , {E1} )V1={v1,v2,v3,v4,v5} G1={ (v1,v2),(v2,v3),(v3,v4),(v3,v5),(v1,v4),(v2,v5) }图的抽象数据类型定义：123456ADT Graph&#123; 数据对象V：顶点集； 数据关系R：R=&#123;VR&#125; VR=&#123;&lt;v,w&gt;|v,w∈V,且P(v,w), &lt;v,w&gt;表示从v到w的弧， P(v,w)定义了弧&lt;v,w&gt;的意义或信息&#125;&#125; 图的基本操作1 CreateGraph(&amp;G, V, VR);初始条件：V是图的顶点集，VR是图中弧的集合操作结果：按V和VR的定义构造图G2 DestroyGraph(&amp;G);初始条件：图G存在操作结果：销毁图G3 LocateVex(G,u);初始条件：图G存在，u和G中顶点有相同特征操作结果：若G中存在顶点u，则返回该顶点在图中位置；否则返回其它信息。4 GetVex(G, v);初始条件：图G存在，v是G中某个顶点操作结果：返回v的值5 PutVex(&amp;G, v, value);初始条件：图G存在，v是G中某个顶点操作结果：对v赋值value6 FirstAdjVex(G, v);初始条件：图G存在，v是G中某个顶点操作结果：返回v的第一个邻接顶点。若顶点在G中没有邻接顶点，则返回“空”。7 NextAdjVex(G, v, w);初始条件：图G存在，v是G中某个顶点，w是v的邻接顶点。操作结果：返回v的（相对于w的）下一个邻接顶点。若w是v的最后一个邻接点，则返回“空”。8 InsertVex(&amp;G, v);初始条件：图G存在，v和图中顶点有相同特征。操作结果：在图G中增添新顶点v9 DeleteVex(&amp;G, v);初始条件：图G存在，v和图中顶点有相同特征操作结果：删除G中顶点v及相关的弧10 InsertArc(&amp;G, v, w); 初始条件：图G存在，v和w是G中两个顶点。 操作结果：在G中增添弧&lt;v,w&gt;，若G是无向的，则还增添对称弧&lt;w,v&gt;11 DeleteArc(&amp;G, v, w); 初始条件：图G存在，v和w是G中两个顶点。 操作结果：在G中删除弧&lt;v,w&gt;，若G是无向的，则还删除对称弧&lt;w,v&gt;12 DFSTraverse(G, v, Visit( )); 初始条件：图G存在，v是G中某个顶点，Visit是顶点的应用函数。 操作结果：从顶点v起深度优先遍历图G，对每个顶点调用函数Visit一次且仅一次。一旦visit( )失败，则操作失败13 BFSTraverse(G, v, Visit( )); 初始条件：图G存在，v是G中某个顶点，Visit是顶点的应用函数。 操作结果：从顶点v起广度优先遍历图G，对每个顶点调用函数Visit一次且一次。一旦visit( )失败，则操作失败子图 设有两个图G =（V,E）G1 =（V1,E1）,若V1∈V,E1 ∈ E,则称 G1是G的子图； 编辑器打不出集合包含符号，先用∈代替 常见的图 1.有向完全图n个顶点的有向图最大边数是n(n-1) 2.完全图n个顶点的无向图最大边数是n(n-1)/2 3.稀疏图/稠密图边数少为前者，多为后者 4.权与图的边或弧相关的数为权 5.网带权的图顶点的度 无向图中，顶点的度为与每个顶点相连的边数 有向图中，顶点的度分成入度与出度 入度：以该顶点为头的弧的数目 出度：以该顶点为尾的弧的数目 邻接点 对于无向图G=(V,{E})，如果边 (v,v’)∈E，则称顶点v和v’互为邻接点(Adjacent)，即v和v’相邻接。边(v,v’) 依附(Incident) 于顶点v和v’或者说 (v,v‘)和顶点v和v’相关联。 对于有向图G=(V,{A}))，如果弧&lt;v,v’&gt;∈A，则称顶点v邻接到顶点v’,顶点v’邻接自顶点v，弧&lt;v,v’&gt;和顶点v,v’相关联**。 路径两个顶点之间的顶点序列，该序列的每个顶点与其前驱是邻接点，每个顶点与其后继也是邻接点 路径长度——沿路径边的数目或沿路径各边权值之和 回路——第一个顶点和最后一个顶点相同的路径叫~ 简单路径——序列中顶点不重复出现的路径叫~ 简单回路——除了第一个顶点和最后一个顶点外，其余顶点不重复出现的回路叫~ 连通图（强连通图） 无向图中，若任意两点都存在路径，此图是连通图。 有向图中，若任意两点都存在互通路径，此图是强连通图。 连通分量无向图G的极大连通子图成为G的连通分量。 极大连通子图：该子图是G连通子图，将G的任何不在该子图中的顶点加入，子图不再连通。 强连通分量有向图D的极大强连通子图成为D的强连通分量。 极大强连通子图意思是：该子图是D强连通子图，将D的任何不在该子图中的顶点加入，子图不再是强连通的。 下面总结了如何判断连通子图是不是极大或极小连通子图。（这个问题好像在离散数学提到过） 若在一个连通子图中，包含了与其中顶点有关所有边（the more the better），则是极大连通子图；若只包含了必不可少的边（the less the better），那就是极小连通子图。 关于此概念，下面的博文讲的很好，上面的总结也是受教于这位博主。原文链接：https://blog.csdn.net/merlyn_yang/article/details/82467980 版权声明：本文为CSDN博主「merlyn_yang」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。 生成树 包含无向图G所有顶点的的极小连通子图称为G生成树。它含有图中全部顶点，但只有足以构成一棵树的n-1条边。一棵有n个顶点的生成树有且仅有n-1条边。","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://daybreakland.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"枕草子","slug":"枕草子-春曙为最","date":"2019-11-23T09:05:52.000Z","updated":"2019-11-25T14:27:54.359Z","comments":true,"path":"2019/11/23/枕草子-春曙为最/","link":"","permalink":"https://daybreakland.top/2019/11/23/%E6%9E%95%E8%8D%89%E5%AD%90-%E6%98%A5%E6%9B%99%E4%B8%BA%E6%9C%80/","excerpt":"","text":"清少纳言随笔《枕草子》的第一篇，恬淡自由，勾勒出四时之美。 まくらのそうし·春はあけぼの &#8195;春は、あけぼの。やうやう白くなりゆく、山ぎは少し明りて、紫だちたる雲のほそくたなびきたる。 夏は、夜。月のころはさらなり、闇もなほ、蛍の多く飛びちがひたる。また、ただ一つ二つなど、ほのかにうち光りて行くも、をかし。雨など降るも、をかし。 秋は、夕暮れ。夕日のさして、山の端いと近うなりたるに、烏の寝どころへ行くとて、三つ四つ、二つ三つなど、飛び急ぐさへあはれなり。まいて、雁などのつらねたるが、いと小さく見ゆるは、いとをかし。日入り果てて、風の音、虫の音(ね)など、はた言ふべきにあらず。 冬は、つとめて。雪の降りたるは言ふべきにもあらず。霜のいと白きも、またさらでも、いと寒きに、火など急ぎおこして、炭持て渡るも、いとつきづきし。昼になりて、ぬるくゆるびもていけば、火桶の火も白き灰がちになりて、わろし。 枕草子·春曙为最 &#8195;春，曙为最。逐渐转白的山顶，开始稍露光明，泛紫的细云轻飘其上。 &#8195;夏则夜。有月的时候自不待言，无月的暗夜，也有群萤交飞。若是下场雨什么的，那就更有情味了。 &#8195;秋则黄昏。夕阳照耀，近映山际，乌鸦返巢，三只、四只、两只的飞过，平添感伤。又有时见雁影小小，列队飞过远空，尤绕风情。而况，日入以后，尚有风声虫鸣。 &#8195;冬则晨朝。降雪时不消说，有时霜色皑皑，即使无雪亦无霜，寒气凛冽，连忙生一盆火，搬运炭火跑过走廊，也挺合时宜；只可惜晌午时分，火盆里头炭木渐蒙白灰，便无甚可赏了。 翻译来源：《枕草子》（清少纳言著，林月文译）原文来源：http://www.eonet.ne.jp/~log-inn/03honkan.htm","categories":[],"tags":[{"name":"摘抄","slug":"摘抄","permalink":"https://daybreakland.top/tags/%E6%91%98%E6%8A%84/"}]},{"title":"论文Introduction改写","slug":"hello-world","date":"2019-11-22T12:13:32.936Z","updated":"2019-12-03T05:09:14.385Z","comments":true,"path":"2019/11/22/hello-world/","link":"","permalink":"https://daybreakland.top/2019/11/22/hello-world/","excerpt":"","text":"提要：论文Introduction部分还是简洁为妙。 其中，尤其是需要答辩的论文，毕竟答辩期间Introduction部分时间占比是相当之少的。所以改写版本相比原版删去或整合了很多内容，希望没有改变作者原本的意思。 同时，由于这一部分的本意是阐述写作目的，提出问题并强调研究意义，其中要描述本领域研究现状，又要突出强调自己研究的拓展、创新之处，为正文的论述做准备，所以语句应尽量做到不拖泥带水，过渡和转折到位，充分为正文蓄势。Introduction 简洁地交代下背景&amp;&amp;现状 Since the discovery of X rays in 1895,radiation has been shrouded in myths and partly as a doomsday power destined to cause the ultimate destruction of mankind. In our own time, fear seems to be the prevalent characteristic of the public perception of radiation phenomena, and the treatment in the media of incidents like the Chernobyl accident has greatly contributed to the spreading of uneasiness and fear. 结合背景，交代下写作目的 Due to above background, the general public’s perception towards radiation is mostly shallow, for most of them are lacking of basic knowledge of radiation. Why should we expect the public to know something about radioactivity and radiation? Three of the most evident answers are the following: The pragmatic reasonPeople should be capable of protecting themselves from the harmful effects of radiation as well as avoiding excessive fear. The democratic reasonPeople should be capable of informed judgements in political matters involving radiation phenomena, nuclear energy, waste disposal, exposure limit etc. The educational reasonThe individual derives pleasure and fulfillment from knowing something about the world around him/her. 介绍相关问题地研究状况，指出他人局限，强调本篇地研究更具有意义和代表性 A critical task is to detect how much understanding the mass have about the radioactivity and radiation via doing a systematic investigation and study. For instant, Lijnse et al. described concepts of radioactivity and radiation held by 15- and 16-year-old pupils in the Netherlands, and Eijkelhof and Millar analyzed British newspaper reports of the Chernobyl accident to identify features of the lay understanding of radiation phenomena. However, today we are to focus on doing a survey on a rather more typical and representative group, which the previous research didn’t perform so well. 本篇调查方式和主体简介，引入正文 The present survey was conducted to investigate the understanding of radiation phenomena and risk among Norwegians with a reasonable level of general education, but lacking specialization in physical science.","categories":[],"tags":[]}]}